
<html lang="en">
<head>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&amp;display=swap" rel="stylesheet"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" rel="stylesheet"/>
<link href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" rel="stylesheet"/>
</head></html><script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
<!-- DEPENDENCY: ADMIN LOGIN LOGIC -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.min.js"></script>
<!-- DEPENDENCY: TEXT EDITOR -->
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet"/>
<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
<!-- DEPENDENCY: COLOR PICKER -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.4.5/jscolor.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-hexbin@1.0.0/dist/leaflet.hexbin.min.js"></script>


<!-- SCRIPT DEPENDENCIES END -->
<script>
document.addEventListener("DOMContentLoaded", () => {
    const popupTexts = {  
        'Login': {
            title: 'Admin-Zugriff',
            text: `<form id="loginForm">
                <label for="username">Benutzer:</label>
                <input type="text" id="username" name="username"><br><br>

                <label for="password">Passwort:</label>
                <input type="password" id="password" name="password"><br><br>

                <label for="otp">OTP 2FA Token:</label>
                <input type="text" id="otp" name="otp"><br><br>

                <button type="submit" class="button-menu" style="padding: 20px; background-color: #35b7ff; border: none; cursor: pointer;">
                    <span style="position: relative; top: 0px;">Anmelden</span>
                </button>
            </form>`,
            color: 'white',
            persist: true
        },
        'uigif-counter': {
            title: 'So funktioniert Filtern:',
            text: '<img src="static/uigif-counter.gif" alt="uigif-counter" style="max-width: 100%; max-height: 800px; width: auto; height: auto;">',
            color: '#ffffff',
            persist: true  // Keep this popup visible forever
        },
		'admin-pindelete': {
        title: 'Einzelne Pins löschen:',
        text: '<img src="static/uigif-deletebyid.gif" alt="uigif-deletebyid" style="max-width: 100%; max-height: 800px; width: auto; height: auto;">',
        color: '#ffffff',
        persist: true  // Keep this popup visible forever
		},
		'admin-pinresize': {
        title: 'Größenänderung:',
        text: '<img src="static/uigif-resize.gif" alt="uigif-resize" style="max-width: 100%; max-height: 800px; width: auto; height: auto;">',
        color: '#ffffff',
        persist: true  // Keep this popup visible forever
		},
        'Overlay': {
            title: 'Dieses Bild wird ersetzt:',
            text: '<img src="static/overlay.jpg" alt="Overlay Image" style="max-width: 100%; max-height: 400px; width: auto; height: auto; border-radius: 30px;">',
            color: '#ffffff',
            persist: true  // Keep this popup visible forever
        },
        'Success': {
            title: 'Anmeldung erfolgreich!',
            text: 'Wenn Sie Hilfe benötigen, sehen Sie sich die Anleitung an oder wenden Sie sich an den Entwickler.',
            color: 'green',
            persist: false
        },
        'Willkommen auf der Stimmungskarte!': {
            title: 'Willkommen auf der Stimmungskarte!',
            text: 'Diese Karte ist eine bequeme und einfache Möglichkeit, Ihrer Stadt zu zeigen, wie Sie sich darin fühlen.<br><br>Sie können Hinweise an Orten anbringen, die Sie entweder als angenehm oder problematisch empfinden.<br><br><span style="color: #f77f00; font-weight: bold;">Und so funktioniert es:</span><br><span style="color: #f77f00; font-weight: bold;">1.</span> Wählen Sie eine Kategorie.<br><span style="color: #f77f00; font-weight: bold;">2.</span> Platzieren Sie einen Pin auf der Karte.<br><span style="color: #f77f00; font-weight: bold;">3.</span> Teilen Sie uns Ihre Meinung mit!<br><br><span style="font-weight: bold;">Ihre Beiträge sind anonym und können von der Gemeinde zur Verbesserung des öffentlichen Raums genutzt werden.</span> ',
            color: '#f77f00'
        },
		<!-- CATEGORY EDITING AREA START -->
        'Dieser Ort gefällt mir.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Dieser Ort strahlt eine beruhigende Ruhe aus und bietet eine angenehme Atmosphäre, die zum Entspannen einlädt.  Ob durch seine natürliche Schönheit oder aufregende Aktivitäten, er vermag es, einen positiven Eindruck zu hinterlassen.',
            color: '#FF7043'
        },
        'Hier fühle ich mich unsicher.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Die schlechte Straßenbeleuchtung lässt ein Gefühl der Unsicherheit aufkommen, während betrunkene oder obdachlose Personen die Unbehaglichkeit weiter verstärken.   Hier wäre eine Aufwertung der öffentlichen Infrastruktur und mehr soziale Dienste wünschenswert.',
            color: '#B71C1C'
        },
        'Hier gibt es Probleme mit dem Parken.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Die knappen Parkmöglichkeiten und rücksichtslos abgestellte Fahrzeuge erschweren die Durchfahrt und schaffen ein chaotisches Straßenbild.   Eine bessere Regulierung und Beschilderung könnte hier Abhilfe schaffen.',
            color: '#1565C0'
        },
        'Hier verbringe ich gerne meine Freizeit.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Dieser Ort bietet eine friedliche Oase zum Abschalten oder ein lebendiges Markttreiben, das zum Stöbern einlädt.   Die angenehme Umgebung, sei es ein Bauernmarkt oder ein Kino, macht ihn zu einem beliebten Freizeitziel.',
            color: '#4CAF50'
        },
        'Dieser Ort braucht eine Verbesserung.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Die fehlende Fußgängerüberquerung und der heruntergekommene Anblick, gepaart mit Schlaglöchern im Straßenbelag, rufen nach Verbesserungen.   Eine Aufwertung der Ästhetik und Sicherheit würde den Ort deutlich attraktiver machen.',
            color: '#4E342E'
        },
        'An diesem Ort fehlt ein Service.': {
            title: 'Was kann man zum Beispiel aufschreiben?',
            text: 'Die mangelhafte Busanbindung und geschlossene Apotheken erschweren den Alltag und lassen den Ort weniger serviceorientiert erscheinen.   Eine Verbesserung der öffentlichen Dienstleistungen wäre hier von Vorteil.',
            color: 'white'
        },
		<!-- CATEGORY EDITING AREA END -->

    };

    // Function to create and show the popup
    let popupTimer;
    let buttonTimer;

    function showPopup(info) {
        clearTimeout(popupTimer);
        const existingPopup = document.getElementById("info-popup");
        if (existingPopup) {
            existingPopup.remove();
        }
		
		

        const popup = document.createElement("div");
        popup.id = "info-popup";
        popup.style.backgroundColor = isLightMode ? "rgba(212,215,218, 1)" : "rgba(17, 17, 17, 1)";
        popup.style.color = isLightMode ? "black" : "white";
        popup.style.borderRadius = "30px";
        popup.style.position = "absolute";
        popup.style.bottom = "10px";
        popup.style.right = "10px";
        popup.style.marginLeft = "10px";
        popup.style.marginTop = "10px";
        popup.style.zIndex = "1000";
        popup.style.opacity = "0";
        popup.style.transition = "opacity 0.2s ease-in";

        const title = document.createElement("h3");
        title.style.color = info.color;
        title.style.fontWeight = "bold";
        title.style.fontSize = "24px";
        title.innerHTML = info.title;
        popup.appendChild(title);

        const text = document.createElement("p");
        text.style.fontWeight = "bold";
        text.style.fontSize = "18px";
        text.innerHTML = info.text;
        popup.appendChild(text);

        document.getElementById("map").appendChild(popup);

        popup.addEventListener('click', function (event) {
            event.stopPropagation();
        });

        setTimeout(() => {
            popup.style.opacity = "1";
        }, 0);

        let timeout = 5000;  // Default timeout in milliseconds
        if (info.title === 'Willkommen auf der Stimmungskarte!') {
            timeout = 15000;  // 15 seconds for 'Willkommen' popup
        } else if (info.title === 'Dieses Bild wird ersetzt:') {
            timeout = -1;  // Infinite for 'Overlay' popup
        }
		
		// Check if this is the 'uigif-counter' popup and add a specific class
		if (info.title === 'So funktioniert Filtern:') {
        popup.classList.add('uigif-counter-popup');
		} else if (info.title === 'Größenänderung:') {
        popup.classList.add('admin-pinresize-popup');
} else if (info.title === 'Einzelne Pins löschen:') {
    popup.classList.add('admin-pindelete-popup');

		}
		
        if (!info.persist) {
            clearTimeout(popupTimer);
            popupTimer = setTimeout(() => {
                popup.style.opacity = "0";
                setTimeout(() => {
                    popup.remove();
                }, 500);
            }, timeout);
        }
    }

    function activatePopup() {
        const info = popupTexts['Willkommen auf der Stimmungskarte!'];
        showPopup(info);
    }

    function activatePopupByKey() {
        const info = popupTexts['Login'];
        showPopup(info);

        const loginForm = document.getElementById("loginForm");
        if (loginForm) {
            loginForm.addEventListener("submit", function (event) {
                event.preventDefault();
                const formData = new FormData(loginForm);
                const username = formData.get("username");
                const password = formData.get("password");
                const otp = formData.get("otp");

                fetch("/login", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    body: `username=${username}&password=${password}&otp=${otp}`,
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === "success") {
                            const successInfo = popupTexts['Success'];
                            showPopup(successInfo);

                            const imageToHide = document.querySelector(".hide-on-mobile.resistant-image");
                            if (imageToHide) {
                                imageToHide.style.display = 'none';
                            }

                            const h3ElementsToHide = document.querySelectorAll(".resistant-h3");
                            if (h3ElementsToHide) {
                                h3ElementsToHide.forEach((element) => {
                                    element.style.display = 'none';
                                });
                            }

                            const adminTools = document.querySelector(".admintools-container");
                            if (adminTools) {
                                adminTools.style.display = 'block';
                            }
                        } else {
                            alert("Failed: " + data.message);
                        }
                    })
                    .catch(error => {
                        alert("An error occurred: " + error);
                    });
            });
        }
    }
	
// Add new code here
const counterContainer = document.getElementById('counter-container');
let isUIGifCounterPopupVisible = false;
// New code for admin-pindelete
const adminPinDelete = document.getElementById('adminpindelete');
let isAdminPinDeletePopupVisible = false;

if (adminPinDelete) {
    adminPinDelete.addEventListener('mouseover', () => {
        if (!isAdminPinDeletePopupVisible) {
            const adminPinDeleteInfo = popupTexts['admin-pindelete'];
            showPopup(adminPinDeleteInfo);
            isAdminPinDeletePopupVisible = true;
        }
    });

    adminPinDelete.addEventListener('mouseout', () => {
        if (isAdminPinDeletePopupVisible) {
            const existingPopup = document.getElementById("info-popup");
            if (existingPopup) {
                existingPopup.style.opacity = "0";
                setTimeout(() => {
                    existingPopup.remove();
                }, 500);
            }
            isAdminPinDeletePopupVisible = false;
        }
    });
}


if (counterContainer) {
    counterContainer.addEventListener('mouseover', (event) => {
        if (!isUIGifCounterPopupVisible) {
            const uigifCounterInfo = popupTexts['uigif-counter'];
            showPopup(uigifCounterInfo);
            isUIGifCounterPopupVisible = true;
        }
    });

    counterContainer.addEventListener('mouseout', (event) => {
        // Check if the mouse is actually leaving the counterContainer or simply moving to a child element
        const isMouseLeavingContainer = !counterContainer.contains(event.relatedTarget);
        
        if (isUIGifCounterPopupVisible && isMouseLeavingContainer) {
            const existingPopup = document.getElementById("info-popup");
            if (existingPopup) {
                existingPopup.style.opacity = "0";
                setTimeout(() => {
                    existingPopup.remove();
                }, 500);
            }
            isUIGifCounterPopupVisible = false;
        }
    });
}

// New code for admin-pinresize
const adminPinResize = document.getElementById('adminpinresize');
let isAdminPinResizePopupVisible = false;

if (adminPinResize) {
    adminPinResize.addEventListener('mouseover', () => {
        if (!isAdminPinResizePopupVisible) {
            const adminPinResizeInfo = popupTexts['admin-pinresize'];
            showPopup(adminPinResizeInfo);
            isAdminPinResizePopupVisible = true;
        }
    });

    adminPinResize.addEventListener('mouseout', () => {
        if (isAdminPinResizePopupVisible) {
            const existingPopup = document.getElementById("info-popup");
            if (existingPopup) {
                existingPopup.style.opacity = "0";
                setTimeout(() => {
                    existingPopup.remove();
                }, 500);
            }
            isAdminPinResizePopupVisible = false;
        }
    });
}

    let isOverlayPopupVisible = false;

    window.toggletitelbildMenu = function () {
        var titelbildMenu = document.getElementById('titelbild-menu');
        if (titelbildMenu.style.display === 'none') {
            titelbildMenu.style.display = 'block';
            const overlayInfo = popupTexts['Overlay'];
            showPopup(overlayInfo);
            isOverlayPopupVisible = true;
        } else {
            titelbildMenu.style.display = 'none';
            if (isOverlayPopupVisible) {
                const existingPopup = document.getElementById("info-popup");
                if (existingPopup) {
                    existingPopup.style.opacity = "0";
                    setTimeout(() => {
                        existingPopup.remove();
                    }, 500);
                }
                isOverlayPopupVisible = false;
            }
        }
    };
	
	 // Add new code here
    const videoDiv = document.getElementById('videoDiv');

    if (videoDiv) {
        videoDiv.addEventListener('click', () => {
            window.open('https://www.youtube.com/watch?v=rHXzX-cQWIs', '_blank');
        });
    }
	
	// New code for infoDiv
    const infoDiv = document.getElementById('infoDiv');
    if (infoDiv) {
        infoDiv.addEventListener('click', () => {
            window.open('https://info.stimmungskompass.at', '_blank');
        });
    }


    const keyDiv = document.querySelector("#keyDiv");
    if (keyDiv) {
        keyDiv.addEventListener("click", activatePopupByKey);
    }

    const buttonMenu = document.querySelector(".button-menu");
    if (buttonMenu) {
        buttonMenu.addEventListener("click", activatePopup);
    }

    const categorybuttons = document.querySelectorAll(".categorybutton");
    categorybuttons.forEach(menu => {
        menu.addEventListener("click", (event) => {
            const title = event.currentTarget.querySelector("h3").textContent;
            const info = popupTexts[title];
            showPopup(info);
        });
    });
});
</script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://leaflet.github.io/Leaflet.heat/dist/leaflet-heat.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script><title>Stimmungskarte Krems | MUSTER</title>
<style type="text/css">body { background-color: #1b1b1b; }
/* Ensure categorybutton-container takes up all remaining space but doesn't extend beyond sidebar */
#sidebar {
    display: flex;
    flex-direction: column;
    overflow: hidden; /* Hide overflow */
}
#categorybutton-container {
    flex-grow: 1;
    overflow-y: auto; /* Add scroll if content overflows */
}
.categorybutton {
    flex-shrink: 1; /* Allow categorybuttons to shrink */
}
</style>
<style>
.texteditor-button {
    background-color: white;
    color: black;
    padding: 10px;
    cursor: pointer;
    border: none;
	margin-right: 5px;
	border-radius: 10px;
}

.star-button {
    background-color: #35b7ff;
    color: white;
    padding: 10px;
    cursor: pointer;
    border: none;
	margin-right: 5px;
	border-radius: 10px;
}

 #editor-container {
        height: 400px;
		display: block;
    }

        .pin-style {
            position: relative;
        }
        .star-icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .star-icon {
            width: 100%;
            height: 100%;
        }
		
img[src="/static/star_icon.png"] {
    z-index: 200;
    position: relative;  /* Ensure that z-index applies */
}



.text-padding {
    padding: 0 2px;
}

#hamburger-menu-container {
    width: 100%;
    box-sizing: border-box;
    flex-grow: 1;
}

#hamburger-dropdown .categorybutton {
    border: none;  /* Remove borders */
    border-radius: 30px;  /* Remove rounded edges */
    height: 20px;  /* Make it thin */
    width: 100%;  /* Take full width of the parent container */
    box-sizing: border-box;  /* To include padding and border in width */
}

#hamburger-dropdown {
  max-height: calc(135% + 0px);  /* 17px away from the bottom */
    width: 100%;  /* Take the full width of hamburger-menu-container */
    box-sizing: border-box; /* To include padding and border in width */
    position: relative;  /* Change from absolute to relative */
    z-index: 1;  /* To make sure it appears above other elements */
    overflow-y: auto;  /* Enable vertical scrolling if content overflows */

}

.toggle-menu-button {
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 14px 0;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer;
    text-decoration: none;
	    white-space: normal;
    border-radius: 30px;
    transition: background-color 0.2s ease-in-out;
    color: white;
    text-align: center;
    line-height: 1;
    max-height: 40px;
    width: 100%;
}




.category2-menu-button {
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 14px 0;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer;
    text-decoration: none;
	    white-space: normal;
    border-radius: 30px;
    transition: background-color 0.2s ease-in-out;
    color: white;
    text-align: center;
    line-height: 1;
    max-height: 40px;
    width: 100%;
}

.titelbild-menu-button {
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 14px 0;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer;
    text-decoration: none;
	    white-space: normal;
    border-radius: 30px;
    transition: background-color 0.2s ease-in-out;
    color: white;
    text-align: center;
    line-height: 1;
    max-height: 40px;
    width: 100%;
}

.pinsexport-menu-button {
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 14px 0;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer;
    text-decoration: none;
	    white-space: normal;
    border-radius: 30px;
    transition: background-color 0.2s ease-in-out;
    color: white;
    text-align: center;
    line-height: 1;
    max-height: 40px;
    width: 100%;
}


.admin-menu-button {
    font-weight: bold;
    border: 5px solid white;
    padding: 7px 0;
    margin: 2px 0;
    cursor: pointer;
    font-size: 24px;
    text-decoration: none;
    display: block;
    width: 100%;
    transition: background-color 0.2s ease-in-out;
    border-radius: 30px;
    box-sizing: border-box;
    text-align: center;
    color: white;
}

.button-menu {
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 14px 0;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer;
    text-decoration: none;
	    white-space: normal;
    border-radius: 30px;
    transition: background-color 0.2s ease-in-out;
    color: white;
    text-align: center;
    line-height: 1;
    max-height: 40px;
    width: 100%;
}

.admin-pinresize {
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 14px 0;
    padding: 15px;
    box-sizing: border-box;
    cursor: pointer;
    text-decoration: none;
	    white-space: normal;
    border-radius: 30px;
    transition: background-color 0.2s ease-in-out;
    color: white;
    text-align: center;
    line-height: 1;
    max-height: 40px;
    width: 100%;
}

.categorybutton {
    font-weight: bold;
    margin: 8px 0;  /* Increased vertical margin for more gap between elements */

    line-height: 1;  /* Adjusted line-height */
    cursor: pointer;
    text-decoration: none;
    display: flex;  /* Changed to flexbox */
    align-items: center;  /* Vertically center content */
    justify-content: center;  /* Horizontally center content */
    width: 100%;
	height: auto;
    box-sizing: border-box;  /* Ensure padding and border are included in the width */
    transition: background-color 0.2s ease-in-out;
    border-radius: 30px;
    text-align: center;

}

.categorybutton h3 {
    padding: 5px 5px;  /* Adds 2px padding to left and right */
    margin: 5px;  /* Removes any default margin */
    color: white;
}

#categorybutton-container {
    width: 100%;
    box-sizing: border-box;
    padding-bottom: 17px; /* Added to ensure 17px space at the bottom */
}


/* Map zoom control CSS */
.leaflet-bar {
  border-radius: 30px !important;
  background-color: #3a3a3a !important;
}

/* Style the zoom-in and zoom-out buttons */
.leaflet-control-zoom-in, .leaflet-control-zoom-out {
  background-color: #3a3a3a !important;
  color: white !important;
  border: none !important;
  font-size: 18px !important;
  line-height: 30px !important;
  width: 30px !important;
  height: 30px !important;
}


/* Change the color when zooming is disabled */
.leaflet-disabled {
  background-color: #111111 !important;
  color: white !important;
}

/* Remove borders from buttons */
.leaflet-control-zoom-in, .leaflet-control-zoom-out {
  border-top: none !important;
  border-bottom: none !important;
  border-radius: 0 !important;
}

/* Add rounded corners to the first and last buttons */
.leaflet-bar > a:first-child {
  border-top-left-radius: 30px !important;
  border-top-right-radius: 30px !important;
}

.leaflet-bar > a:last-child {
  border-bottom-left-radius: 30px !important;
  border-bottom-right-radius: 30px !important;
}







/* Layer control CSS */
.leaflet-control-layers-toggle {
    font-size: 30px;
    line-height: 24px;
    font-weight: bold;
    text-align: center;
    border-radius: 30px;
    background-color: transparent;
    background-repeat: no-repeat;
    background-position: center;
    width: 36px;
    height: 36px;
}

.leaflet-control-layers {
    border-radius: 30px;
    opacity: 1;
}

.leaflet-control-layers::before {
    content: "";
    background-image: url('static/mapicon2.png');
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 30px;
    background-size: cover;
    opacity: 1;
}

.leaflet-control-layers-expanded {
    background-color: #3a3a3a !important;
}

/* Hide the background image when the control layers menu is expanded */
.leaflet-control-layers-expanded::before {
    content: none !important;
}

.leaflet-control-layers-expanded .leaflet-control-layers-list {
    color: white;
    font-size: 15px;
    font-weight: bold;
    padding: 10px;  /* Added padding here */
}

.leaflet-control-layers-selector {
    border: 1px solid white !important;
    margin: 2px !important;
}

.leaflet-popup .leaflet-popup-content-wrapper .leaflet-popup-content {
    font-size: 20px !important;
}

/* Your existing rules for .leaflet-control-layers and .leaflet-top leaflet-right had typos, corrected below */
.leaflet-control-layers.leaflet-control {
    border-radius: 30px;
}

.leaflet-top.leaflet-right {
    border-radius: 50px;
}


/* Hover effect */
.button-menu:hover, .categorybutton:hover, .post-button:hover, .key-div:hover, .video-div:hover, .info-div:hover, .lightswitch-div:hover {
    filter: brightness(85%);
    border-width: 5px;  /* Make this the same as the initial border width */
    border-color: white;
}

/* Existing styles, updated */
.button-menu, .categorybutton, .post-button, .key-div, .video-div, .info-div, .lightswitch-div {
    box-sizing: border-box;
    transition: all 0.2s ease-in-out;
    border: 5px solid transparent; /* Set initial transparent border */
}

    .popup-image {
        max-width: 100%;
        max-height: 400px;  /* Adjust based on your needs */
        width: auto;
        height: auto;
    }





/* Selected effect */
.button-menu.selected, .categorybutton.selected, .key-div.selected, .video-div.selected, .info-div.selected, .lightswitch-div.selected {
    filter: brightness(85%);
    border-width: 5px;
    border-color: white;
}

.molen-id{
opacity: 0;
}
.molen-id hidden{
opacity: 0;
}
</style>
<style>
    #info-popup {
        padding: 20px;
        max-width: 500px;
        font-size: 14px;
        z-index: 1000;  /* Make sure the popup appears above the map */
    }
#info-popup.admin-pindelete-popup {
    max-width: 300px;
}
	
	#info-popup.uigif-counter-popup {
    max-width: 270px;
}

#info-popup.uigif-counter-popup img {
    border-radius: 30px;
}

#info-popup.admin-pinresize-popup {
 max-width: 300px;
}

</style>
<script>
</script>
<style>
        /* New styles for the popup */
        .leaflet-popup-content-wrapper,.leaflet-popup-tip {
            background-color: #111111 !important;
            color: white !important;
            font-family: 'Roboto', sans-serif !important;
            z-index: 1000 !important;
        }
    </style>
<style>
  #info-popup {
    border-radius: 30px !important;
  }
  #feedbackText {
    font-family: 'Roboto', sans-serif !important;
  }
</style>
<style>
  #info-popup,
  .leaflet-popup,
  #postFeedback,
  #cancelFeedback {
    border-radius: 30px !important;
  }
  #feedbackText {
    color: white !important;
  }
  
  
  .custom-checkbox-wrapper {
    display: inline-block;
    background-color: #111111;
    color: white;
	margin-top: 4px;
    padding: 5px 20px;
    border-radius: 30px;  /* Rounded corners */
    cursor: pointer;
}

.custom-checkbox-label {
    display: inline;
}
</style>
<style>
/* Ensure categorybutton-container takes up all remaining space */
#sidebar {
    display: flex;
    flex-direction: column;
}
#categorybutton-container {
    flex-grow: 1;
}
</style>

<style>
/* Dark mode styles (default) */
.dark-mode {
    --bg-color1: #1b1b1b;
    --bg-color2: #111111;
    --bg-color3: #3a3a3a;
    --text-color: #ffffff;
    --logo-img: "static/logo_long.png";
    --key-icon: "static/keyicon.png";
    --sun-icon: "static/sunicon.png";
    --info-icon: "static/infoicon.png";
    --video-icon: "static/videoicon.png";
}

/* Light mode styles */
.light-mode {
    --bg-color1: #F4F4ED;
    --bg-color2: #D4D7DA;
    --bg-color3: #000000;
    --text-color: #000000;
    --logo-img: "static/logo_long2.png";
    --key-icon: "static/keyicon2.png";
    --sun-icon: "static/sunicon2.png";
    --info-icon: "static/infoicon2.png";
    --video-icon: "static/videoicon2.png";
}
</style>

<script>
let isDarkMode = true; // Initially, the website is in dark mode

function togglePopup() {
    isDarkMode = !isDarkMode;
    document.documentElement.classList.toggle('dark-mode', isDarkMode);
    document.documentElement.classList.toggle('light-mode', !isDarkMode);
}
</script>
<body>
<!-- POPUP -->
<!-- Counter container -->
<div class="main-container" style="background-color= solid #0D1F22">
<!-- Add this button where you want it to appear on your HTML page -->
<div style="display: flex; height: 100vh">
<div id="map" style="flex-basis: 70%; border-radius: 30px; margin-left: 15px; margin-top: 15px; margin-bottom: 15px;">
<!-- COUNTER / VIS DIV -->
<div class="parent-container">
<div class="countercontainer" id="counter-container" style="background-color: #3a3a3a;">
</div>
</div>
<div class="togglebuttoncontainer" id="togglebutton-container">
</div>
</div>
<div class="color-111111" id="sidebar" style="flex-basis: 30%; background-color: #111111; margin-bottom: 15px; margin-top: 15px; border-radius: 30px">
<div style="display: flex; align-items: center;">
</div>
<img class="logo-img" src="static/logo_long.png" style="max-width: 100%; height: auto; display: block; margin-bottom: 7px; border-radius: 0px;"/>
<!-- BEGINNING OF EDITABLE AREA -->
<h3 class="resistant-h3 text-white" style="color: white;">Wie stehen Sie zu den Orten in Ihrer Gemeinde?</h3>
<h3 class="resistant-h3 text-white" style="color: white; margin-top: -10px; margin-bottom: 7px">Lassen Sie es uns auf dieser Karte wissen! </h3>
<!-- ENDING OF EDITABLE AREA -->


 


<div class="xdxd">
<div class="left-container">
<div class="video-div" id="videoDiv" onclick="togglePopup()" style="border-radius:30px;">
<img src="static/videoicon.png"/>
</div>
<div class="info-div" id="infoDiv" onclick="togglePopup()" style="border-radius:30px;">
<img src="static/infoicon.png"/>
</div>
</div>
<!-- Center aligned button -->
<div class="button-menu color-3a3a3a" id="buttonMenu" onclick="addAndRemoveClass()" style="background-color: #3a3a3a; margin-left:auto; margin-right:auto; width: auto; height: auto; padding: 15px;">
<h3> Wie funktioniert's?</h3>
</div>
<!-- Container for right-aligned elements -->
<div class="right-container">
<div class="lightswitch-div" id="lightswitchDiv" onclick="togglePopup()" style="border-radius:30px;">
<img src="static/sunicon.png"/>
</div>
<div class="key-div" id="keyDiv" onclick="togglePopup()" style="border-radius:30px;">
<img src="static/keyicon.png"/>
</div>
<!-- ADMIN IMPORT TBD START -->
<!-- RESIZER IMPORT -->
<!-- TEXT EDITOR: WIE FUNKTIONIERTS ADMIN END -->
</div>
</div>
<div class="admintools-container color-111111 text-white" style="display:none;             color: #ffffff;  /* This makes the text color white */
background-color: #111111; margin-top: 15px;  margin-bottom: 15px; border-radius: 30px">
<button class="button-menu" id="aboutBtnEditor" onclick="toggleEditorMenu()" style="background-color: #35b7ff">Texteditor</button>
<!-- Popup Container -->
<div id="editor-menu" style="display:none;">
<!-- TEXT EDITOR: WIE FUNKTIONIERTS ADMIN -->
<div id="infoModalEditor" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color: rgba(0, 0, 0, 0.7); align-items:center; justify-content:center; z-index:100000;">
<div class="info-field" id="conditionsField" style="overflow-y: auto; max-height: 100vh;">
<div id="editor-container" style="height: 400px; overflow-y: auto;"></div>
<button class="texteditor-button" id="prevAreaButton" onclick="prevArea()" style="margin-top:10px; text-align: center;">Vorheriger Teil</button>
<button class="texteditor-button" id="nextAreaButton" onclick="nextArea()" style="margin-top:10px; text-align: center;">Nächster Teil</button>
<button class="texteditor-button" id="saveButton" onclick="updateText()" style="margin-top:10px; text-align: center;">Änderungen speichern</button>
</div>
</div>
<!-- TEXT EDITOR: WIE FUNKTIONIERTS ADMIN END -->
</div>

<!-- HEATMAPZ EDITOR ADMIN START -->


 <!-- Heatmap settings menu -->
 <button class="button-menu" id="heatmap-menu-button" onclick="toggleHeatmapMenu()" style="background-color: #35b7ff">Heatmapeditor</button>
  <div class ="heatmapsettings" id="heatmapSettings" style="display:none;">
    
<h2>Heatmap Settings</h2>
<label>
  Min Opacity: <input type="range" id="minOpacity" step="0.1" value="0.1" min="0" max="1">
</label><br>
<label>
  Max Zoom: <input type="range" id="maxZoom" value="18" min="0" max="20">
</label><br>
<label>
  Max Intensity: <input type="range" id="max" step="0.1" value="1.0" min="0" max="2">
</label><br>
<label>
  Radius: <input type="range" id="radius" value="25" min="0" max="50">
</label><br>
<label>
  Blur: <input type="range" id="blur" value="15" min="0" max="30">
</label><br>
 </label><br>
    <label>
      Gradient (JSON):
      <textarea id="gradient" rows="4" cols="50">{"0.4": "blue", "0.65": "lime", "1": "red"}</textarea>
    </label><br>
	
	  <!-- Buttons for import and export -->
  <button class="delete-button"onclick="updateHeatmapSettings()">Update Settings</button>
  <button class="delete-button" onclick="exportSettings()">Export Settings</button>
  <input class="delete-button" type="file" id="importFile" style="display:none;" onchange="importSettings()" />
  <button class="delete-button" onclick="document.getElementById('importFile').click()">Import Settings</button>
  </div>






<button class="button-menu" id="titelbild-menu-button" onclick="toggletitelbildMenu()" style="background-color: #35b7ff">Titelbild</button>
<div id="titelbild-menu" style="display:none;">
<div id="hoverDiv" style="display: flex; justify-content: center; flex-direction: column; align-items: center; margin-top: 10px">
<h3 style="margin-top: 2px; margin-bottom: 2px;">Titelbild ersetzen:</h3>
<form action="/upload_overlay_image" enctype="multipart/form-data" method="post" style="text-align: left;">
<label for="file"></label>
<input accept="image/*" id="file" name="file" required="" type="file"/>
<input class="delete-button" type="submit" value="Ändern"/>
</form>
</div>
</div>


<button class="button-menu" id="pinsexport-menu-button" onclick="togglePinsExportMenu()" style="background-color: #35b7ff">Pins</button>

<div id="pinsexport-menu" style="display:none;">



<div class="admin-pinresize" id="adminpinresize" style="display: flex; justify-content: center; flex-direction: column; align-items: center; margin-top: 10px; background-color: 111111">
<h3 style="margin-top: 2px; margin-bottom: 6px;">Größenänderung:</h3>
</div>
<div style="display: flex; justify-content: center; flex-direction: column; align-items: center; margin-top: 10px">

<div style="display: flex; flex-direction: row; align-items: center; gap: 10px">
<div id="resize-section" style="display: flex; flex-direction: row; align-items: center; gap: 10px;"></div>
</div>
</div>




<div class="admin-pindelete" id="adminpindelete" style="display: flex; justify-content: center; flex-direction: column; align-items: center; margin-top: 10px; background-color: 111111">
<h3 style="margin-top: 2px; margin-bottom: -2px;">Pins löschen:</h3>
</div>

<div style="display: flex; justify-content: center; flex-direction: column; align-items: center; margin-top: 10px">

<select id="delete-pin-type-dropdown">
<option value="all">Alle Pins</option> <!-- New option for all pins -->
<option value="FF7043">Dieser Ort gefällt mir.</option>
<option value="B71C1C">Hier fühle ich mich unsicher.</option>
<option value="1565C0">Hier gibt es Probleme mit dem Parken.</option>
<option value="4CAF50">Hier verbringe ich gerne meine Freizeit.</option>
<option value="4E342E">Dieser Ort braucht eine Verbesserung.</option>
<option value="212121">An diesem Ort fehlt ein Service.</option>
</select>
<button class="delete-button" id="deletePinsByType" style="margin-left: 6px">Löschen</button>
</div>

<div style="display: flex; justify-content: center; flex-direction: column; align-items: center; margin-top: 10px">

<h3 style="margin-top: 2px; margin-bottom: 1px;">Pins herunterladen:</h3>
<div style="display: inline-block; text-align: left; margin-top: 6px;">
<form action="/export_geojson" method="get" style="display: flex; flex-direction: row; align-items: center; gap: 10px;">
<select id="pin-type-dropdown" name="pin_type">
<option value="">Alle Pins</option>
<!-- CATEGORY EDITING AREA START -->
<option value="FF7043">Dieser Ort gefällt mir.</option>
<option value="B71C1C">Hier fühle ich mich unsicher.</option>
<option value="1565C0">Hier gibt es Probleme mit dem Parken.</option>
<option value="4CAF50">Hier verbringe ich gerne meine Freizeit.</option>
<option value="4E342E">Dieser Ort braucht eine Verbesserung.</option>
<option value="212121">An diesem Ort fehlt ein Service.</option>
<!-- CATEGORY EDITING AREA END -->
</select>
<button class="delete-button" type="submit">GeoJSON herunterladen (Pins)</button>
</form>
</div>
<h3 style="margin-top: 2px; margin-bottom: 1px;">Laden Sie eine GeoJSON Datei hoch:</h3>
<div style="display: inline-block; text-align: left; margin-top: 6px;">
<form action="/upload_geojson" enctype="multipart/form-data" method="post">
<label for="geojson_file"></label>
<input accept=".json,application/json" name="geojson_file" type="file"/>
<button class="delete-button" type="submit">Hochladen</button>
</form>
</div>
</div>
</div>
<button class="button-menu" id="category2-menu-button" onclick="toggleCategory2Menu()" style="background-color: #35b7ff">Kategorien</button>
<div id="category2-menu" style="display:none;">
<div style="display: flex; justify-content: center; flex-direction: column; align-items: center; margin-top: 10px">
<h3>Create New Pin Category:</h3>
<form id="new-category-form" style="text-align: left; margin-top: 6px">
<label for="category-name">Category Name:</label>
<input id="category-name" name="category-name" required="" type="text"/><br/><br/>
<label for="category-color">Category Color:</label>
<input id="category-color" name="category-color" required="" type="color" value="#EDFF86"/><br/><br/>
<input class="delete-button" type="submit" value="Create Category"/>
<button class="delete-button" id="add-category-button">Add a Category</button>
</form>
</div>
<div style="display: flex; justify-content: center; flex-direction: column; align-items: center; margin-top: 10px">
<h3>Kategorien umfärben:</h3>
<form id="recolor-form" style="text-align: left; margin-top: 6px">
<div style="display: flex; justify-content: center; gap: 10px;">
<select id="recolor-category-dropdown" name="category"></select>
<input id="new-color" name="newColor" type="color" value="#ffffff"/>
<button class="delete-button" id="recolorCategory" type="button">Recolor Category</button>
</div>
</form>
</div>
<div style="text-align: center;">
<div style="display: flex; flex-direction: column; align-items: center;">
<h3>Kategorien umbenennen:</h3>
<div style="display: flex; margin-top: 6px">
<select id="rename-category-dropdown"></select>
<input id="new-category-name" placeholder="Neuer Name" type="text"/>
<button class="delete-button" id="renameCategory" style="margin-left: 8px">Umbenennen</button>
</div>
</div>
</div>
</div>
</div>
<img class="hide-on-mobile resistant-image" src="static/overlay.jpg" style="max-width: 100%; height: auto; display: block; margin-left:auto; margin-right:auto; margin-top: 3px; margin-bottom: 8px; border-radius: 30px;"/>
<!-- Mappy Container -->
<div id="mappy-container">
<div id="mapMobile">
<!-- COUNTER / VIS DIV -->
</div>
</div>
<!-- Pin Menu -->
<div class="centered-text-container" style="margin-bottom: 0px;">
</div>
<div class="current-desktop">
<div class="options" id="dropdown-options">
<!-- CATEGORY EDITING AREA START -->
<form id="new-category-form">
<h3>Add New Category</h3>
<label for="category-name">Name:</label>
<input id="category-name" name="category-name" required="" type="text"/><br/>
<label for="category-color">Color (Hex):</label>
<input id="category-color" name="category-color" required="" type="text"/><br/>
<label for="category-popup">Popup Text:</label>
<textarea id="category-popup" name="category-popup" required=""></textarea><br/>
<input type="submit" value="Create Category"/>
</form>

<form id="new-category-form">
<h3>Add New Category</h3>
<label for="category-name">Name:</label>
<input id="category-name" name="category-name" required="" type="text"/><br/>
<label for="category-color">Color (Hex):</label>
<input id="category-color" name="category-color" required="" type="text"/><br/>
<label for="category-popup">Popup Text:</label>
<textarea id="category-popup" name="category-popup" required=""></textarea><br/>
<input type="submit" value="Create Category"/>
</form>
<div class="categorybutton" data-color="FF7043" style="background-color: #FF7043;">
<h3>Dieser Ort gefällt mir.</h3>
</div>
<div class="categorybutton" data-color="B71C1C" style="background-color: #B71C1C;">
<h3>Hier fühle ich mich unsicher.</h3>
</div>
<div class="categorybutton" data-color="1565C0" style="background-color: #1565C0;">
<h3>Hier gibt es Probleme mit dem Parken.</h3>
</div>
<div class="categorybutton" data-color="4CAF50" style="background-color: #4CAF50;">
<h3>Hier verbringe ich gerne meine Freizeit.</h3>
</div>
<div class="categorybutton" data-color="4E342E" style="background-color: #4E342E;">
<h3>Dieser Ort braucht eine Verbesserung.</h3>
</div>
<div class="categorybutton" data-color="212121" style="background-color: #212121;">
<h3>An diesem Ort fehlt ein Service.</h3>
<!-- CATEGORY EDITING AREA END -->
</div>
</div>
</div>
<!-- Hamburger menu container -->
<div id="hamburger-menu-container" style="display: none;">
<!-- Hamburger menu -->
<div id="hamburger-menu" onclick="toggleHamburgerDropdown()">
</div>
<!-- Hamburger dropdown -->
<div id="hamburger-dropdown" style="display: none">
<!-- CATEGORY EDITING AREA START -->
<div class="categorybutton" data-color="FF7043" style="background-color: #FF7043;">
<h3>Dieser Ort gefällt mir.</h3>
</div>
<div class="categorybutton" data-color="B71C1C" style="background-color: #B71C1C;">
<h3>Hier fühle ich mich unsicher.</h3>
</div>
<div class="categorybutton" data-color="1565C0" style="background-color: #1565C0;">
<h3>Hier gibt es Probleme mit dem Parken.</h3>
</div>
<div class="categorybutton" data-color="4CAF50" style="background-color: #4CAF50;">
<h3>Hier verbringe ich gerne meine Freizeit.</h3>
</div>
<div class="categorybutton" data-color="4E342E" style="background-color: #4E342E;">
<h3>Dieser Ort braucht eine Verbesserung.</h3>
</div>
<div class="categorybutton" data-color="212121" style="background-color: #212121;">
<h3>An diesem Ort fehlt ein Service.</h3>
</div>
<!-- CATEGORY EDITING AREA END -->
</div>
</div>
<div id="categorybutton-container">
<!-- CATEGORY EDITING AREA START -->
<div class="categorybutton" data-color="FF7043" style="background-color: #FF7043;">
<h3>Dieser Ort gefällt mir.</h3>
</div>
<div class="categorybutton" data-color="B71C1C" style="background-color: #B71C1C;">
<h3>Hier fühle ich mich unsicher.</h3>
</div>
<div class="categorybutton" data-color="1565C0" style="background-color: #1565C0;">
<h3>Hier gibt es Probleme mit dem Parken.</h3>
</div>
<div class="categorybutton" data-color="4CAF50" style="background-color: #4CAF50;">
<h3>Hier verbringe ich gerne meine Freizeit.</h3>
</div>
<div class="categorybutton" data-color="4E342E" style="background-color: #4E342E;">
<h3>Dieser Ort braucht eine Verbesserung.</h3>
</div>
<div class="categorybutton" data-color="212121" style="background-color: #212121;">
<h3>An diesem Ort fehlt ein Service.</h3>
<!-- CATEGORY EDITING AREA END -->
</div>

</div>
</div>
</div>
<script>
document.addEventListener("DOMContentLoaded", function() {
    let clickableMenus = document.querySelectorAll('.categorybutton, .button-menu');

    clickableMenus.forEach(menu => {
        menu.addEventListener('click', function(e) {
            // Unselect all
            clickableMenus.forEach(m => m.classList.remove('selected'));

            // Select the clicked one
            e.currentTarget.classList.add('selected');
        });
    });
});
</script>
<!-- LOGIC -->
<script>
</script>
<script>


// Initialize main map
    const map = L.map('map').setView([48.4102, 15.6022], 10);
    map.setMinZoom(15);

    // Initialize mobile map
    const mapMobile = L.map('mapMobile').setView([48.4102, 15.6022], 10);
    mapMobile.setMinZoom(14);

    setTimeout(() => {
        mapMobile.invalidateSize(true);
        map.invalidateSize(true);
    }, 1000);

    map.doubleClickZoom.disable();
	



    const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    const osmLayerMobile = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(mapMobile);

    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    });
	
		
		
		
		
		
		
    // Function to load settings from local storage
    function loadSettings() {
      const settings = JSON.parse(localStorage.getItem('heatmapSettings'));
      if (settings) {
        document.getElementById('minOpacity').value = settings.minOpacity;
        document.getElementById('maxZoom').value = settings.maxZoom;
        document.getElementById('max').value = settings.max;
        document.getElementById('radius').value = settings.radius;
        document.getElementById('blur').value = settings.blur;
        document.getElementById('gradient').value = JSON.stringify(settings.gradient, null, 2);
      }
    }		
		
	let heatmapLayer;
let heatmapLayerMobile;

document.addEventListener("DOMContentLoaded", function() {
    map.whenReady(function() {
        // Initialize empty heat layers after map is fully loaded
        heatmapLayer = L.heatLayer([], { radius: 25, scaleRadius: true });  // Do not add to map by default
        console.log("Heatmap layer initialized"); // Log for initialization
        loadSettings();  // Load saved settings
        updateHeatmapSettings();  // Apply saved settings
    });

function loadHeatmap(pins) {
    heatmapData = pins.map(pin => [parseFloat(pin.lat), parseFloat(pin.lon), 0.5])
                      .filter(coord => !isNaN(coord[0]) && !isNaN(coord[1]));
    console.log("Heatmap data:", heatmapData);  // Log the data being passed
    if (heatmapLayer) {
        heatmapLayer.setLatLngs(heatmapData);
        console.log("Heatmap data updated");  // Log for data update
    }
}

    // Fetch pins after DOM is completely loaded
    fetch('/get_pins')
    .then(response => response.json())
    .then(data => {
        if(data && data.pins) {
            loadPins(data.pins);
            loadHeatmap(data.pins);  // Populate heatmap
        }
    });
});
    L.control.layers({
        "Standardkarte": osmLayer,
        "Satellit": satelliteLayer
    }).addTo(map);

    L.control.layers({
        "Standardkarte": osmLayerMobile,
        "Satellit": satelliteLayer
    }).addTo(mapMobile);
	
	map.on('layercontroladd', function() {
    var customButton = document.createElement('button');
    customButton.innerHTML = "Enable Heatmap";
    customButton.id = "enableHeatmap";
    customButton.onclick = function() {
        toggleHeatmap();
    };
	
    var layerBase = document.getElementsByClassName('leaflet-control-layers-base')[0];
    layerBase.appendChild(customButton);
});

    map.on('baselayerchange', function(eventLayer) {
        if (eventLayer.name === 'Satellit') {
            setSatelliteStyle(map);
        } else {
            resetStyle(map);
        }
    });

    mapMobile.on('baselayerchange', function(eventLayer) {
        if (eventLayer.name === 'Satellit') {
            setSatelliteStyle(mapMobile);
        } else {
            resetStyle(mapMobile);
        }
    });
	
	
	const layers = {
    "FF7043": L.layerGroup().addTo(map).addTo(mapMobile),
    "B71C1C": L.layerGroup().addTo(map).addTo(mapMobile),
    "1565C0": L.layerGroup().addTo(map).addTo(mapMobile),
    "4CAF50": L.layerGroup().addTo(map).addTo(mapMobile),
    "4E342E": L.layerGroup().addTo(map).addTo(mapMobile),
    "212121": L.layerGroup().addTo(map).addTo(mapMobile)
};

// Function to add marker to both map and mapMobile
function addMarkerToMaps(latlng, pinType, description) {
    const marker = L.marker(latlng, {
        icon: L.divIcon({
            className: `pin-${pinType}`,
            iconSize: [24, 24]
        })
    }).bindPopup(description);
    
    marker.addTo(layers[pinType]);
}

function loadPins(pins) {
    pins.forEach(pin => addMarkerToMaps([pin.lat, pin.lon], pin.pin_type, pin.description));
}
// Event listeners for checkboxes
document.querySelectorAll(".filter-checkbox").forEach(checkbox => {
    checkbox.addEventListener("change", function() {
        const pinType = this.getAttribute("data-pin-type");
        if (this.checked) {
            map.addLayer(layers[pinType]);
            mapMobile.addLayer(layers[pinType]);
        } else {
            map.removeLayer(layers[pinType]);
            mapMobile.removeLayer(layers[pinType]);
        }
    });
});


function addCustomCheckbox() {
    var layerBase = document.querySelector('.leaflet-control-layers-base');
    if (layerBase) {
        // Create a wrapper div for custom checkbox and label
        var wrapper = document.createElement('div');
        wrapper.className = "custom-checkbox-wrapper";

        // Create a checkbox
        var checkbox = document.createElement('input');
        checkbox.type = "checkbox";
        checkbox.id = "enableHeatmapCheckbox";
        checkbox.style.display = "none";  // Hide the actual checkbox

        // Create a label for the checkbox
        var label = document.createElement('label');
        label.htmlFor = "enableHeatmapCheckbox";
        label.className = "custom-checkbox-label";
        label.appendChild(document.createTextNode('Heatmap'));


        // Attach an onclick event to toggle the heatmap and change wrapper style
        checkbox.onclick = function() {
            toggleHeatmap();
            if (checkbox.checked) {
                wrapper.style.backgroundColor = "#35b7ff";
            } else {
                wrapper.style.backgroundColor = "#111111";
            }
        };

        // Append everything to the wrapper
        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);

        // Append the wrapper to leaflet-control-layers-base
        layerBase.appendChild(wrapper);
    } else {
        setTimeout(addCustomCheckbox, 500);  // If not yet added, retry in 500ms
    }
}
// Add the custom checkbox after map and controls are initialized
setTimeout(addCustomCheckbox, 1000);  // Delay by 1 second to ensure layer control is added


 // Function to export settings as JSON file
  function exportSettings() {
    const settings = {
      minOpacity: document.getElementById('minOpacity').value,
      maxZoom: document.getElementById('maxZoom').value,
      max: document.getElementById('max').value,
      radius: document.getElementById('radius').value,
      blur: document.getElementById('blur').value,
      gradient: document.getElementById('gradient').value
    };
    const blob = new Blob([JSON.stringify(settings)], { type: 'application/json' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'heatmap_settings.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  // Function to import settings from JSON file and auto-update
  function importSettings() {
    const fileInput = document.getElementById('importFile');
    const file = fileInput.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
      const settings = JSON.parse(e.target.result);
      document.getElementById('minOpacity').value = settings.minOpacity;
      document.getElementById('maxZoom').value = settings.maxZoom;
      document.getElementById('max').value = settings.max;
      document.getElementById('radius').value = settings.radius;
      document.getElementById('blur').value = settings.blur;
      document.getElementById('gradient').value = settings.gradient;
      
      // Call the updateHeatmapSettings function to apply the imported settings
      updateHeatmapSettings();
    };
    reader.readAsText(file);
  }

// Function to update heatmap settings
    function updateHeatmapSettings() {
        const minOpacity = parseFloat(document.getElementById('minOpacity').value);
        const maxZoom = parseInt(document.getElementById('maxZoom').value);
        const max = parseFloat(document.getElementById('max').value);
        const radius = parseInt(document.getElementById('radius').value);
        const blur = parseInt(document.getElementById('blur').value);
        const gradient = JSON.parse(document.getElementById('gradient').value);

        if (heatmapLayer) {
            heatmapLayer.setOptions({
                minOpacity: minOpacity,
                maxZoom: maxZoom,
                max: max,
                radius: radius,
                blur: blur,
                gradient: gradient,
                scaleRadius: true  // Keep the form constant
            });
        }

        if (heatmapLayerMobile) {
            heatmapLayerMobile.setOptions({
                minOpacity: minOpacity,
                maxZoom: maxZoom,
                max: max,
                radius: radius,
                blur: blur,
                gradient: gradient,
                scaleRadius: true  // Keep the form constant
            });
        }

        // Save settings to local storage
        localStorage.setItem('heatmapSettings', JSON.stringify({
            minOpacity,
            maxZoom,
            max,
            radius,
            blur,
            gradient
        }));
    }

  // Add event listeners to update heatmap settings whenever the user changes them
  document.getElementById('minOpacity').addEventListener('change', updateHeatmapSettings);
  document.getElementById('maxZoom').addEventListener('change', updateHeatmapSettings);
  document.getElementById('max').addEventListener('change', updateHeatmapSettings);
  document.getElementById('radius').addEventListener('change', updateHeatmapSettings);
  document.getElementById('blur').addEventListener('change', updateHeatmapSettings);
  document.getElementById('gradient').addEventListener('change', updateHeatmapSettings);

  // Load settings on page load
  loadSettings();
  updateHeatmapSettings();

   // Load saved settings on page load
    window.addEventListener('load', loadSettings);

// New code to establish WebSocket connection
const socket = io.connect(location.origin);

// New event listener for 'update_counters' WebSocket message
socket.on('update_counters', function() {
    fetchAndDisplayCounters();
});



    function setSatelliteStyle(mapInstance) {
        const mapContainer = mapInstance.getContainer();
        mapContainer.classList.add("satellite-view");
    }

    function resetStyle(mapInstance) {
        const mapContainer = mapInstance.getContainer();
        mapContainer.classList.remove("satellite-view");
    }

    map.on('click', handleMapClick);
    mapMobile.on('click', handleMapClick);

 

const latlng = [48.4102, 15.6022];
const distanceInKm = Math.sqrt(10);
const point = turf.point([latlng[1], latlng[0]]);
const buffered = turf.buffer(point, distanceInKm / 2, { units: 'kilometers' });
let bbox = turf.bbox(buffered);

// Expanding the bounds to the west and east by about 5km
const expandDistance = 3 / 111.32;  // 5km in degrees (approximate, assuming 1 degree = 111.32km)
bbox[0] -= expandDistance;  // west
bbox[2] += expandDistance;  // east

// Create square coordinates from the updated bbox
let squareCoords = [
    [bbox[0], bbox[1]],  // bottom-left
    [bbox[0], bbox[3]],  // top-left
    [bbox[2], bbox[3]],  // top-right
    [bbox[2], bbox[1]],  // bottom-right
    [bbox[0], bbox[1]]   // back to bottom-left to close the polygon
];

function keepInView(mapInstance, boundaryPolygon) {
    mapInstance.on('moveend', function() {
        const expandedBounds = boundaryPolygon.getBounds().pad(1);  // Expands bounds by 100%
        if (!expandedBounds.contains(mapInstance.getBounds())) {
            mapInstance.fitBounds(boundaryPolygon.getBounds());
        }
    });
}
// ... rest of your code ...









// Create the boundary polygons
// Create the boundary polygons
const squareForMap = L.polygon([
    [squareCoords[0][1], squareCoords[0][0]],
    [squareCoords[1][1], squareCoords[1][0]],
    [squareCoords[2][1], squareCoords[2][0]],
    [squareCoords[3][1], squareCoords[3][0]],
    [squareCoords[4][1], squareCoords[4][0]]
], {color: 'grey', weight: 1, fillColor: 'none'}).addTo(map);

const squareForMapMobile = L.polygon([
    [squareCoords[0][1], squareCoords[0][0]],
    [squareCoords[1][1], squareCoords[1][0]],
    [squareCoords[2][1], squareCoords[2][0]],
    [squareCoords[3][1], squareCoords[3][0]],
    [squareCoords[4][1], squareCoords[4][0]]
], {color: 'grey', weight: 1, fillColor: 'none'}).addTo(mapMobile);

// Apply the keepInView function to both map instances
keepInView(map, squareForMap);
keepInView(mapMobile, squareForMapMobile);




// Add a light grey overlay for the main map
const outerBounds = [
  [-90, -180],
  [-90, 180],
  [90, 180],
  [90, -180]
];

const overlay = L.polygon([outerBounds, [
    [squareCoords[0][1], squareCoords[0][0]],
    [squareCoords[1][1], squareCoords[1][0]],
    [squareCoords[2][1], squareCoords[2][0]],
    [squareCoords[3][1], squareCoords[3][0]],
    [squareCoords[4][1], squareCoords[4][0]]
]], {
    color: 'none',
    fillColor: 'grey',
    fillOpacity: 0.0  // Reduced opacity to 0.1
}).addTo(map);

const overlayMobile = L.polygon([outerBounds, [
    [squareCoords[0][1], squareCoords[0][0]],
    [squareCoords[1][1], squareCoords[1][0]],
    [squareCoords[2][1], squareCoords[2][0]],
    [squareCoords[3][1], squareCoords[3][0]],
    [squareCoords[4][1], squareCoords[4][0]]
]], {
    color: 'none',
    fillColor: 'grey',
    fillOpacity: 0.0  // Reduced opacity to 0.1
}).addTo(mapMobile);




    function calculateBounds(lat, lng, distanceInKm) {
    const R = 6371;  // Earth's radius in kilometers
    const dLat = distanceInKm / R;
    const dLng = distanceInKm / (R * Math.cos((Math.PI * lat) / 180));
    return [
        [lat - dLat, lng - dLng],
        [lat + dLat, lng + dLng]
    ];
}
	// Add this event listener to stop propagation of click events from counter-container
document.getElementById('counter-container').addEventListener('click', function(event) {
    event.stopPropagation();
});

	// Add this event listener to stop propagation of click events from counter-container
document.getElementById('togglebutton-container').addEventListener('click', function(event) {
    event.stopPropagation();
});



	// Add this line to declare currentPopupLatLng
	let currentPopupLatLng = null;
    
    function handleMapClick(e) {
    const targetSquare = e.target === map ? squareForMap : squareForMapMobile;
    
    if (selectedColor === null) {
        alert("Wählen Sie zunächst eine Option aus.");
        return;
    }

    if (targetSquare.getBounds().contains(e.latlng)) {
        // Add this check to see if a popup is already open at the clicked position
        if (currentPopupLatLng && currentPopupLatLng.equals(e.latlng)) {
            return;
        }
        currentPopupLatLng = e.latlng;
		
		

        const containerWidth = document.querySelector('#sidebar').offsetWidth;
        const fontSize = Math.max(12, containerWidth / 30);

        const popupContent = `
            <textarea id="feedbackText" rows="4" cols="40" placeholder="Was denken Sie über diesen Ort?" style="font-size: ${fontSize}px;"></textarea><br>
            <button id="postFeedback" class="post-button" style="font-size: ${fontSize}px;">Fertig</button>
            <button id="cancelFeedback" class="cancel-button"style="font-size: ${fontSize}px;">Löschen</button>
        `;

        const popup = L.popup()
            .setLatLng(e.latlng)
            .setContent(popupContent)
            .openOn(e.target);

           
    // Global variable to store the list of bad words
let badWords = [];


// Fetch the list of bad words from filter.json
fetch('/static/filter.json')
    .then(response => response.json())
    .then(data => {
        // Merge the arrays of bad words from different languages into one array
        badWords = [].concat(...Object.values(data));
    });

// Updated event listener for the 'postFeedback' button
document.getElementById('postFeedback').addEventListener('click', function() {
    const feedback = document.getElementById('feedbackText').value;

    // Create a RegExp pattern from the list of bad words
    const badWordPattern = new RegExp(`${badWords.join('|')}`, 'i');
    const hasBadWord = badWordPattern.test(feedback);
    
    if (hasBadWord) {
        createPopup("Beleidigende Worte sind nicht erlaubt.", 'map');
        createPopup("Beleidigende Worte sind nicht erlaubt.", 'mapMobile');
        return;
    }

    // Pattern to detect repeated letters (same letter repeating more than 4 times)
    const repeatedLetterPattern = /(.)\1{4,}/;
    const hasRepeatedLetters = repeatedLetterPattern.test(feedback);
    
    if (hasRepeatedLetters) {
        createPopup("Wiederholte Buchstaben sind nicht erlaubt.", 'map');
        createPopup("Wiederholte Buchstaben sind nicht erlaubt.", 'mapMobile');
        return;
    }

    // Pattern to detect links (http, https, www, or domain names)
    const linkPattern = /(http:\/\/|https:\/\/|www\.|\.(com|net|org|info|io|at|de|uk|co|gov|edu|eu|biz|tv|me|us|ca|au|nz))/i;
    const hasLink = linkPattern.test(feedback);

    if (hasLink) {
        createPopup("Links sind nicht erlaubt.", 'map');
        createPopup("Links sind nicht erlaubt.", 'mapMobile');
        return;
    }

    if (feedback.length >= 10 && feedback.length <= 150) {
                    L.marker(e.latlng, {
                        icon: L.divIcon({
                            className: `pin-style pin-${selectedColor}`,
                            iconSize: [24, 24]
                        })
                    }).bindPopup(feedback).addTo(e.target);
					
					
					


                   // Generate a random molen_id
        const molen_id = Math.random().toString(36).substring(2, 10);

        fetch('/add_pin', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        lat: e.latlng.lat,
        lon: e.latlng.lng,
        pin_type: selectedColor,
        description: feedback,
        molen_id: `M${Math.floor(Math.random() * 1e9)}`  // Generate a random molen_id client-side
    })
});


                    e.target.closePopup();
                } else {
            alert("Bitte geben Sie zwischen 10 und 150 Zeichen ein.");
                }
            });

            document.getElementById('cancelFeedback').addEventListener('click', function() {
                popup._close();
            });
        } else {
            alert("Sie dürfen Notizen nur innerhalb des Stadtgebiets platzieren.");
        }
    }

    function loadPins(pins) {
    pins.forEach(pin => {
        const marker = L.marker([pin.lat, pin.lon], {
            icon: L.divIcon({
                className: `pin-${pin.pin_type}`,
                iconSize: [24, 24]
            })
        }).bindPopup(`
            ${pin.description}
            <br>
            <button onclick="deletePin('${pin.molen_id}')">Delete</button>
        `).addTo(layers[pin.pin_type]);
    });
}



function deletePin(molen_id) {
            // Refresh the heatmap using new set of pins
            if (data.new_pins) {
                loadHeatmap(data.new_pins);
            }

    fetch(`/delete_pin_by_molen_id/${molen_id}`, {
        method: 'POST'
    }).then(response => response.json())
    .then(data => {
        if (data.success) {
		    loadHeatmap(data.new_pins);  // Refresh the heatmap using new set of pins
            // Remove the pin from the map
            // Assuming you have stored your markers in a global object called `markers`
            const marker = markers[molen_id];
            if (marker) {
                marker.remove();
                delete markers[molen_id];  // Remove the marker from the markers object
            }
        } else {
            alert('Error deleting pin');
        }
    });
}



    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    const pins = {
        "FF7043": "Something to be proud of",
        "B71C1C": "Unsafe area",
        "1565C0": "Parking issues",
        "4CAF50": "Nice to spend free time at",
        "4E342E": "Needs improvement",
        "212121": "Missing service"
    };
	
	





// Global object to keep track of toggle states
const toggleStates = {
    "FF7043": true,
    "B71C1C": true,
    "1565C0": true,
    "4CAF50": true,
    "4E342E": true,
    "212121": true
};

// Store the markers in an object so you can reference them later
const markers = {
    "FF7043": [],
    "B71C1C": [],
    "1565C0": [],
    "4CAF50": [],
    "4E342E": [],
    "212121": []
};

// Updated loadPins function to handle opacity
function loadPins(pins) {
    pins.forEach(pin => {
        const marker = L.marker([pin.lat, pin.lon], {
            icon: L.divIcon({
                className: `pin-${pin.pin_type}`,
                iconSize: [24, 24]
            }),
            opacity: toggleStates[pin.pin_type] ? 1 : 0.05  // Set opacity based on toggle state
        }).bindPopup(pin.description);

        marker.addTo(layers[pin.pin_type]);
        markers[pin.pin_type].push(marker);  // Store the marker
    });
}

   // Updated script to handle toggle-button menu interactions
    document.querySelectorAll('.toggle-button').forEach(button => {
        button.addEventListener('click', () => {
            // Refresh the heatmap based on visible pins
            const visiblePins = Array.from(document.querySelectorAll('.leaflet-marker-icon'))
                                      .filter(marker => marker.style.opacity !== '0.05')
                                      .map(marker => {
                                          const latLng = marker._leaflet_pos;
                                          return [latLng.lat, latLng.lng, 0.5];  // Adjust the weight (0.5) as needed
                                      });
            loadHeatmap(visiblePins);

            const pinType = button.getAttribute('data-pin-type');
            toggleStates[pinType] = !toggleStates[pinType];  // Toggle the state

            // Toggle the display styles of the img tags
            const untoggledIcon = button.querySelector('.untoggled-icon');
            const toggledIcon = button.querySelector('.toggled-icon');
            untoggledIcon.style.display = toggleStates[pinType] ? '' : 'none';
            toggledIcon.style.display = toggleStates[pinType] ? 'none' : '';

            // Update the opacity of existing markers of the same type
            document.querySelectorAll(`.pin-${pinType}`).forEach(markerElement => {
                markerElement.style.opacity = toggleStates[pinType] ? 1 : 0.05;
            });
        });
    });


</script>
<script>

<!-- LOGIC - DROPDOWN MOBILE -->

document.querySelector('#dropdown-button').addEventListener('click', function() {
    let options = document.querySelector('#dropdown-options');
    if (options.style.display === 'none' || !options.style.display) {
        options.style.display = 'block';
    } else {
        options.style.display = 'none';
    }
});

let categorybuttons = document.querySelectorAll('.categorybutton');
categorybuttons.forEach(function(menu) {
    menu.addEventListener('click', function() {
        let color = this.getAttribute('data-color');
        let text = this.querySelector('h3').textContent;
        document.querySelector('#dropdown-button').textContent = text;
        document.querySelector('#dropdown-button').style.backgroundColor = '#' + color;
        
        document.addEventListener('DOMContentLoaded', function () {
    const dropdownButton = document.getElementById('dropdown-button');
    const dropdownOptions = document.getElementById('dropdown-options');
    const categorybuttons = document.querySelectorAll('.categorybutton');
    const allPins = document.querySelectorAll('.pin'); // Assuming all pins have a class of 'pin'

    // Toggle the visibility of the dropdown options when the button is clicked
    dropdownButton.addEventListener('click', function () {
        dropdownOptions.style.display = dropdownOptions.style.display === 'block' ? 'none' : 'block';
    });

    // Add a click event for each pin menu option
    categorybuttons.forEach(function (menu) {
        menu.addEventListener('click', function (e) {
            const selectedText = e.target.closest('.categorybutton').querySelector('h3').textContent; // Get the text of the selected option

            dropdownButton.textContent = `Ausgewählt: ${selectedText}`; // Update the button text

            const selectedColor = e.currentTarget.getAttribute('data-color');
            showPins(selectedColor); // Activate the corresponding pins

            // Close the dropdown after selection
            dropdownOptions.style.display = 'none';
        });
    });

    function showPins(colorCode) {
        // Hide all pins by default
        allPins.forEach(pin => pin.style.display = 'none');

        // Show only the pins that match the selected color code
        const matchingPins = document.querySelectorAll(`.pin[data-color="${colorCode}"]`);
        matchingPins.forEach(pin => pin.style.display = 'block');
    }
});

    });
});

</script>
<script>

<!-- LOGIC - COLOR OF CURRENTLY CHOSEN TEXT -->
document.addEventListener("DOMContentLoaded", function() {
    // Get all categorybutton elements
    var categorybuttons = document.querySelectorAll('.categorybutton');

    // Add click event to each categorybutton
    categorybuttons.forEach(function(menu) {
        menu.addEventListener('click', function() {
            // Get the color from the clicked categorybutton
            var color = menu.getAttribute('data-color');

            // Update the color and text of the 'selected-pin-type' span
            var selectedPinType = document.getElementById('selected-pin-type');
            selectedPinType.style.color = "#" + color;
            selectedPinType.innerText = menu.querySelector('h3').innerText;
        });
    });
});

</script>
<script>
window.addEventListener("resize", function() {
    mapMobile.invalidateSize();
});

</script>
<!-- TEXT EDITOR GENERAL BEGINNING -->
<script>
    function toggleEditorMenu() {
        var editorMenu = document.getElementById('editor-menu');
        if (editorMenu.style.display === 'none') {
            editorMenu.style.display = 'block';
        } else {
            editorMenu.style.display = 'none';
        }
    }
	
	
</script>
<script>
    var quill;
    var editableAreas = [];
    var currentAreaIndex = 0;

    function initEditor() {
	    console.log("initEditor called");
        if (quill) {
            return;
        }

        fetch('/get_editable_content')
            .then(response => response.json())
            .then(data => {
                editableAreas = data.areas;
                initializeQuill();
            });
    }

    function initializeQuill() {
        quill = new Quill('#editor-container', {
            theme: 'snow',
            modules: {
                toolbar: [
                    [{ 'header': [1, 2, 3, false] }],
                    [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                    ['bold', 'italic', 'underline', 'strike'],
                    [{ 'color': [] }, { 'background': [] }],
                    [{ 'align': [] }],
                ],
            },
        });

        loadArea(currentAreaIndex);
    }

    function loadArea(index) {
        quill.clipboard.dangerouslyPasteHTML(editableAreas[index][0]);
        quill.format('align', 'center');
    }

    function nextArea() {
        currentAreaIndex = (currentAreaIndex + 1) % editableAreas.length;
        loadArea(currentAreaIndex);
    }

    function prevArea() {
        currentAreaIndex = (currentAreaIndex - 1 + editableAreas.length) % editableAreas.length;
        loadArea(currentAreaIndex);
    }

    function updateText() {
        var new_text = quill.root.innerHTML;
        var file_path = editableAreas[currentAreaIndex][1];
        fetch('/update_text', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                text: new_text,
                areaIndex: currentAreaIndex,
                filePath: file_path,
            }),
        }).then(response => {
            if (response.status === 200) {
                alert("Text successfully changed!");
                location.reload();
            }
        });
    }

    document.addEventListener('DOMContentLoaded', initEditor);

</script>
<!-- TEXT EDITOR GENERAL END -->
<!-- PIN RESIZING START -->
   <script>
        let pinSize = 24;  // Default pin size
        let starIconSize = 26;  // Default star icon size

        function resizePins(size) {
            pinSize = size;  // Update the global pinSize variable
            starIconSize = size + 2;  // Star icon is always 2 points bigger than the pins

            document.querySelectorAll('.star-icon').forEach(star => {
                star.style.width = `${starIconSize}px`;
                star.style.height = `${starIconSize}px`;
            });

            localStorage.setItem('starIconSize', starIconSize);
            localStorage.setItem('pinSize', size);

            fetch('/resize_pins', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    size: size,
                }),
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    console.error('Failed to update pin size on server:', data.error);
                }
            });

            refreshMap();
        }

    function createStarIcon() {
        console.log(`highlight_id is set for pin: ${pin.molen_id}`);  // Debug line
        const starIcon = L.icon({
            iconUrl: '/static/star_icon.png',
            iconSize: [starIconSize, starIconSize],  // Use the variable starIconSize
            iconAnchor: [starIconSize / 2, starIconSize / 2],  // Center the icon based on its size
            className: 'star-icon'  // Add a class name to the star icon
        });
        return starIcon;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const resizeSection = document.getElementById('resize-section');
        const resizeLabel = document.createElement('label');
        const resizeDropdown = document.createElement('select');
        const customSizeInput = document.createElement('input');
        const resizeButton = document.createElement('button');

        resizeLabel.textContent = "";

        const sizes = {
            20: 'S',
            24: 'M',
            32: 'L',
            48: 'XL'
        };

        for (const [size, label] of Object.entries(sizes)) {
            const option = document.createElement('option');
            option.value = size;
            option.text = label;
            resizeDropdown.appendChild(option);
        }

        customSizeInput.type = 'number';
        customSizeInput.min = '10';
        customSizeInput.max = '100';
        customSizeInput.placeholder = 'Custom Size (10 to 100)';

        resizeButton.className = 'delete-button';
        resizeButton.textContent = 'Größe ändern';
		resizeButton.style.padding = '10px';
		resizeButton.style.backgroundColor = '#000000';
		resizeButton.style.border = 'none';
		resizeButton.style.cursor = 'pointer';

        resizeButton.addEventListener('click', function() {
            const newSize = parseInt(customSizeInput.value) || parseInt(resizeDropdown.value);
            if (newSize >= 10 && newSize <= 100) {
                resizePins(newSize);
            } else {
                alert('Please enter a size between 10 and 100');
                customSizeInput.value = '';  // Reset custom size input field
            }
        });

        resizeDropdown.addEventListener('change', function() {
            resizePins(parseInt(this.value));
        });

        resizeSection.appendChild(resizeLabel);
        resizeSection.appendChild(resizeDropdown);
        resizeSection.appendChild(customSizeInput);
        resizeSection.appendChild(resizeButton);

        // Load the saved sizes from localStorage
        const savedPinSize = localStorage.getItem('pinSize');
        const savedStarIconSize = localStorage.getItem('starIconSize');
        if (savedPinSize && savedStarIconSize) {
            pinSize = parseInt(savedPinSize);
            starIconSize = parseInt(savedStarIconSize);
            resizePins(pinSize);  // Apply the saved pin size
            // Set the value of the dropdown and/or custom input field
            resizeDropdown.value = savedPinSize;
            customSizeInput.value = savedPinSize;
        }
    });

</script>
<!-- PIN RESIZING END -->
<!-- PIN DELETING GENERAL START -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const deletePinsByTypeButton = document.getElementById('deletePinsByType');
    const deletePinTypeDropdown = document.getElementById('delete-pin-type-dropdown');

    deletePinsByTypeButton.addEventListener('click', function() {
        const selectedPinType = deletePinTypeDropdown.value;
        if (!selectedPinType) {
            alert('Please select a pin type.');
            return;
        }

        const confirmDelete = selectedPinType === 'all'
            ? confirm("Are you sure you want to delete all pins?")
            : confirm(`Are you sure you want to delete all pins of type ${selectedPinType}?`);

        if (confirmDelete) {
            // Remove from frontend
            const classNameToMatch = selectedPinType === 'all' ? '' : selectedPinType;
            map.eachLayer(function(layer) {
                if (layer instanceof L.Marker && layer.options.icon.options.className.includes(classNameToMatch)) {
                    map.removeLayer(layer);
                }
            });

            mapMobile.eachLayer(function(layer) {
                if (layer instanceof L.Marker && layer.options.icon.options.className.includes(classNameToMatch)) {
                    mapMobile.removeLayer(layer);
                }
            });

            // Update the URL for the fetch call based on the selected option
            const url = selectedPinType === 'all'
                ? '/delete_all_pins'
                : `/delete_pins_by_type/${selectedPinType}`;

            // Remove from backend
            fetch(url, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`All pins${selectedPinType === 'all' ? '' : ` of type ${selectedPinType}`} deleted successfully`);
                } else {
                    console.log(`Failed to delete pins${selectedPinType === 'all' ? '' : ` of type ${selectedPinType}`}`);
                }
            })
            .catch(error => {
                console.log(`An error occurred while deleting pins${selectedPinType === 'all' ? '' : ` of type ${selectedPinType}`}:`, error);
            });
        }
    });
});

</script>
<!-- PIN DELETING GENERAL END -->
<!--CATEGORY RENAMING START -->
<script>
   document.addEventListener('DOMContentLoaded', (event) => {
    fetch('/get_categories')
        .then(response => response.json())
        .then(categories => {
            const dropdown = document.getElementById('rename-category-dropdown');
            console.log('Existing Options:', dropdown.options);  // Log existing options
            dropdown.innerHTML = '';  // Clear any existing options
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category.value;
                option.text = category.name;
                dropdown.add(option);
            });
        });
});

document.getElementById('renameCategory').addEventListener('click', () => {
    const colorCode = document.getElementById('rename-category-dropdown').value;
    const newName = document.getElementById('new-category-name').value;
    fetch('/rename_category', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({value: colorCode, newName: newName})
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Die Kategorie wurde erfolgreich umbenannt!');
            location.reload();  // Reload the page
        } else {
            alert('Die Kategorie konnte nicht umbenannt werden!');
        }
    });
});
</script>
<!-- CATEGORY RENAMING END -->
<!-- ADMINTOOLS CATEGORY LOADING START -->
<script>
    function toggleMenu() {
        var toggleMenu = document.getElementById('toggle-menu');
        if (toggleMenu.style.display === 'none' || toggleMenu.style.display === '') {
            toggleMenu.style.display = 'block';  // Show the menu
        } else {
            toggleMenu.style.display = 'none';  // Hide the menu
        }
    }
</script>
<script>
    function toggleAdminMenu() {
        var adminMenu = document.getElementById('admin-menu');
        if (adminMenu.style.display === 'none') {
            adminMenu.style.display = 'block';
        } else {
            adminMenu.style.display = 'none';
        }
    }
</script>
<script>
    function togglePinsExportMenu() {
        var menu = document.getElementById('pinsexport-menu');
        var button = document.getElementById('pinsexport-menu-button');
        if (menu.style.display === 'none' || menu.style.display === '') {
            menu.style.display = 'block';
        } else {
            menu.style.display = 'none';
            button.classList.remove('toggled');
        }
    }
</script>
<script>
    function toggleCategory2Menu() {
        var category2Menu = document.getElementById('category2-menu');
        if (category2Menu.style.display === 'none') {
            category2Menu.style.display = 'block';
        } else {
            category2Menu.style.display = 'none';
        }
    }
</script>
<script>
    function toggletitelbildMenu() {
        var titelbildMenu = document.getElementById('titelbild-menu');
        if (titelbildMenu.style.display === 'none') {
            titelbildMenu.style.display = 'block';
        } else {
            titelbildMenu.style.display = 'none';
        }
    }
</script>

<script>
function toggleHeatmapMenu() {
  var heatmapSettings = document.getElementById("heatmapSettings");
  if (heatmapSettings.style.display === "none" || heatmapSettings.style.display === "") {
    heatmapSettings.style.display = "block";
  } else {
    heatmapSettings.style.display = "none";
  }
}
</script>

<script>
    function toggleEditorMenu() {
        var editorMenu = document.getElementById('editor-menu');
        if (editorMenu.style.display === 'none') {
            editorMenu.style.display = 'block';
        } else {
            editorMenu.style.display = 'none';
        }
    }
	
	
</script>
<!-- ADMINTOOLS CATEGORY LOADING END-->
<!-- RESIZING LOGIC GENERAL BEGINNING -->
<script>
function updateFontSize() {
    const windowWidth = window.innerWidth;
    const isMobile = windowWidth <= 780; // Check if the device is mobile
    const sidebar = document.querySelector('#sidebar');
    const containerWidth = sidebar.offsetWidth;

    // Dynamically update flex-basis for #map and #sidebar
    const mapElement = document.querySelector('#map');
    const sidebarElement = sidebar;

    if (!isMobile) {
        mapElement.style.flexBasis = '70%';
        sidebarElement.style.flexBasis = '30%';
    } else {
        mapElement.style.flexBasis = '100%';
        sidebarElement.style.flexBasis = '0%';
    }


    mapElement.style.flexBasis = `${flexBasisMap}%`;
    sidebarElement.style.flexBasis = `${flexBasisSidebar}%`;
   

    const baseFontSize = isMobile ? Math.max(16, containerWidth / 20) : Math.max(12, containerWidth / 30);

    // Update the font sizes for elements as before
    document.querySelectorAll('#aboutBtn, #dropdown-button, #current-selection').forEach(el => {
        el.style.fontSize = `${baseFontSize}px`;
    });

    const regularH2FontSize = Math.min(30, baseFontSize);
    document.querySelectorAll('#sidebar h2:not(.centered-text-container h2)').forEach(h2 => {
        h2.style.fontSize = `${regularH2FontSize}px`;
    });

    const centeredH2FontSize = Math.max(15, containerWidth / 25);
    document.querySelectorAll('.centered-text-container h2').forEach(h2 => {
        h2.style.fontSize = `${centeredH2FontSize}px`;
    });

    // Handling categorybutton and button-menu separately to prevent resizing until necessary
    ['categorybutton', 'button-menu'].forEach(menuClass => {
        if (!isMobile) {
            document.querySelectorAll(`.${menuClass}`).forEach(el => {
                el.style.fontSize = 'initial';
            });
        } else {
            const menuWidth = document.querySelector(`.${menuClass}`).offsetWidth;
            const menuFontSize = Math.max(12, menuWidth / 30);
            document.querySelectorAll(`.${menuClass}`).forEach(el => {
                el.style.fontSize = `${menuFontSize}px`;
            });
        }
    });

    // Add the logic to scale the elements inside the 'xdxd' div
    const xdxdFontSize = Math.max(12, containerWidth / 30);
    document.querySelectorAll('.xdxd').forEach(div => {
        div.style.fontSize = `${xdxdFontSize}px`;
    });

        const sidebarHeight = sidebar.offsetHeight;
    const availableSpace = sidebarHeight - 17; // 17px away from the bottom
    const categorybuttonDesktop = document.querySelector('#categorybutton-container');
    const allPins = document.querySelectorAll('.categorybutton');

    const numberOfPins = allPins.length;
    const newMaxHeight = Math.max(20, Math.floor(availableSpace / numberOfPins) - 2); // -2 to account for margins

    allPins.forEach(pin => {
        pin.style.maxHeight = `${newMaxHeight}px`;
        // Force repaint for max-height to take effect
        void pin.offsetHeight;
    });
}

// Function to update category button heights
function updateCategoryButtonHeight() {
    const sidebar = document.getElementById('sidebar');
    const categorybuttonContainer = document.getElementById('categorybutton-container');
    const categorybuttons = categorybuttonContainer.querySelectorAll('.categorybutton');
    const hamburgerDropdown = document.getElementById('hamburger-dropdown');
    const dropdownCategoryButtons = hamburgerDropdown.querySelectorAll('.categorybutton');

    let otherElementsHeight = 0;
    Array.from(sidebar.children).forEach(child => {
      if (child.id !== 'categorybutton-container' && child.id !== 'hamburger-menu-container') {
        otherElementsHeight += child.offsetHeight;
      }
    });

    const availableHeight = sidebar.offsetHeight - otherElementsHeight - 135; // 17px away from the bottom
    let newHeight = Math.floor(availableHeight / categorybuttons.length);

    // Update height for category buttons in main container
    categorybuttons.forEach(button => {
      button.style.height = `${newHeight}px`;
    });

    // Ensure a minimum height of 25px for dropdown category buttons
    newHeight = Math.max(40, newHeight);
    dropdownCategoryButtons.forEach(button => {
      button.style.height = `${newHeight}px`;
    });

    // Enable or disable scrolling based on the total height of the dropdown buttons
    const totalDropdownHeight = dropdownCategoryButtons.length * newHeight;
    if (totalDropdownHeight > availableHeight) {
      hamburgerDropdown.style.height = `${availableHeight}px`;
      hamburgerDropdown.style.overflowY = 'scroll';
    } else {
      hamburgerDropdown.style.height = 'auto';
      hamburgerDropdown.style.overflowY = 'hidden';
    }
}


function setHamburgerMenuHeight() {
    const hamburgerMenuContainer = document.getElementById('hamburger-menu-container');
    if (hamburgerMenuContainer) {
        let currentHeight = parseInt(window.getComputedStyle(hamburgerMenuContainer).height, 0);
        hamburgerMenuContainer.style.height = `${currentHeight + 20}px`;
    }
}



// Function to toggle category buttons and hamburger menu based on window height
function toggleCategoryMenu() {
    const windowHeight = window.innerHeight;
    const categoryContainer = document.getElementById('categorybutton-container');
    const hamburgerMenuContainer = document.getElementById('hamburger-menu-container');
    const hamburgerDropdown = document.getElementById('hamburger-dropdown');

    if (windowHeight < 820) {
        categoryContainer.style.display = 'none';
        hamburgerMenuContainer.style.display = 'block';
        hamburgerDropdown.style.display = 'block';  // Automatically display the dropdown

        // Increase the height of the hamburger-menu-container by 20px
        let currentHeightMenu = parseInt(window.getComputedStyle(hamburgerMenuContainer).height, 10);
        hamburgerMenuContainer.style.height = `${currentHeightMenu + 20}px`;


        // Check and set the overflowY property based on content
        const totalDropdownHeight = hamburgerDropdown.scrollHeight;
        const availableHeight = parseInt(hamburgerDropdown.style.height, 10);
        hamburgerDropdown.style.overflowY = totalDropdownHeight > availableHeight ? 'scroll' : 'hidden';
        
    } else {
        categoryContainer.style.display = 'block';
        hamburgerMenuContainer.style.display = 'none';
        hamburgerDropdown.style.display = 'none';
    }
}

// Function to toggle the visibility of the category buttons when the hamburger icon is clicked
function toggleHamburgerDropdown() {
    const dropdown = document.getElementById('hamburger-dropdown');
    dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
}

// Existing event listeners
window.addEventListener('resize', updateFontSize);
window.addEventListener('load', updateFontSize);
window.addEventListener('resize', updateCategoryButtonHeight);
window.addEventListener('load', updateCategoryButtonHeight);
window.addEventListener('resize', toggleCategoryMenu);
window.addEventListener('load', toggleCategoryMenu);



</script>
<script>
async function vote(pinId, action) {
    const res = await fetch('/vote', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ pin_id: pinId, action: action })
    });
    const data = await res.json();
    if (data.votes !== undefined) {
        document.querySelector(`#votes-${pinId}`).textContent = data.votes;
    }
}
</script>
<!--DELETE FUNCTION - PIN REMOVAL -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const deleteAllPinsButton = document.getElementById('deleteAllPins');

    deleteAllPinsButton.addEventListener('click', function() {
        const confirmDelete = confirm("Are you sure you want to delete all pins?");
        
        if (confirmDelete) {
            // Remove from frontend
            map.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    map.removeLayer(layer);
                }
            });

            mapMobile.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    mapMobile.removeLayer(layer);
                }
            });

            // Remove from backend
            fetch('/delete_all_pins', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log("All pins deleted successfully");
                } else {
                    console.log("Failed to delete pins");
                }
            })
            .catch(error => {
                console.log("An error occurred while deleting pins:", error);
            });
        }
    });
});

</script>
<script>
function fetchAndDisplayCounters() {
    // Fetch the counter data from the server
    fetch('/get_counters')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
            }
            return response.json();
        })
        .then(data => {
            let counterContainer = document.getElementById("counter-container");
            let counterContainerMobile = document.getElementById("counter-container-mobile");

            // Check if the elements exist
            if (!counterContainer || !counterContainerMobile) {
                console.error('Counter containers not found');
                return;
            }

            // Clear the existing counters
            counterContainer.innerHTML = "";
            counterContainerMobile.innerHTML = "";

            // Loop through each counter type and append a circle for it
            for (let counterType in data) {
                let counterValue = data[counterType];

                let counterCircle = document.createElement("div");
                counterCircle.className = "counter-circle";
                counterCircle.style.backgroundColor = "#" + counterType;
                counterCircle.innerText = counterValue;

                let counterCircleMobile = counterCircle.cloneNode(true);
                counterCircleMobile.innerText = counterValue;

                counterContainer.appendChild(counterCircle);
                counterContainerMobile.appendChild(counterCircleMobile);
            }
        })
        .catch(error => {
            console.error('There has been a problem with your fetch operation:', error);
        });
}

// You can call this function on page load, or as often as needed to refresh the counter
fetchAndDisplayCounters();

</script>
<script>
// Your existing toggleStates object
let toggleStates = {};

// List of pin-types
const pinTypes = ['FF7043', 'B71C1C', '1565C0', '4CAF50', '4E342E', '212121'];

// Function to create a button for each pin-type and append it to the counter-container
function createButtons() {
  const counterContainer = document.getElementById('counter-container');
  pinTypes.forEach(pinType => {
    const button = document.createElement('button');
    button.className = 'toggle-button';
    button.setAttribute('data-pin-type', pinType);
    button.setAttribute('data-toggled', 'true');

    const untoggledIcon = document.createElement('img');
    untoggledIcon.className = 'icon untoggled-icon';
    untoggledIcon.src = 'static/visicon_universal.png';
    untoggledIcon.alt = 'Visibility Icon';

    const toggledIcon = document.createElement('img');
    toggledIcon.className = 'icon toggled-icon';
    toggledIcon.src = 'static/visicon_universal_2.png';
    toggledIcon.alt = 'Visibility Icon';
    toggledIcon.style.display = 'none';

    button.appendChild(untoggledIcon);
    button.appendChild(toggledIcon);
    counterContainer.appendChild(button);
  });
}

// Function to attach the toggle functionality to buttons
function attachToggleFunctionality() {
  document.querySelectorAll('.toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const pinType = button.getAttribute('data-pin-type');
      toggleStates[pinType] = !toggleStates[pinType];  // Toggle the state

      // Toggle the display styles of the img tags
      const untoggledIcon = button.querySelector('.untoggled-icon');
      const toggledIcon = button.querySelector('.toggled-icon');
      untoggledIcon.style.display = toggleStates[pinType] ? '' : 'none';
      toggledIcon.style.display = toggleStates[pinType] ? 'none' : '';

      // Update the opacity of existing markers of the same type
      document.querySelectorAll(`.pin-${pinType}`).forEach(markerElement => {
        markerElement.style.opacity = toggleStates[pinType] ? 1 : 0.05;
      });
    });
  });
}

// Create buttons and then attach toggle functionality
createButtons();
attachToggleFunctionality();
</script>
<script>
    let filteredType = null;  // Keep track of the currently filtered pin type
    const pinOrder = ['FF7043', 'B71C1C', '1565C0', '4CAF50', '4E342E', '212121'];  // Specify the order of pin types

    function toggleFilter(pin_type) {
        if (filteredType === pin_type) {
            filteredType = null;
        } else {
            filteredType = pin_type;
        }
        // Update your map to show the filtered pins
        updateMap();
    }

    function fetchAndUpdateCounter() {
    fetch('/get_pin_counts')
    .then(response => response.json())
    .then(data => {
        let htmlStr = '';
        pinOrder.forEach(pin_type => {
            let count = data[pin_type];
            // Initially set data-toggled to true, matching the initial visibility state of the pin.
            let initialToggledState = 'true';  // You may need to set this based on the actual initial visibility of the pin.
            htmlStr += `<div class="counter-item">
                            <div class="counter-wrapper">
                                <span class="counter-circle" style="background-color: #${pin_type};" onclick="toggleFilter('${pin_type}')"></span>
                                <button class="toggle-button" data-pin-type="${pin_type}" data-toggled="${initialToggledState}">
                                    <img alt="Visibility Icon" class="icon untoggled-icon" src="static/visicon_universal.png"/>
                                    <img alt="Visibility Icon" class="icon toggled-icon" src="static/visicon_universal_2.png" style="display:none;"/>
                                </button>
                            </div>
                            ${count}
                        </div>`;
        });
        htmlStr += `<div class="counter-item">Alles: ${data.total}</div>`;
        document.getElementById('counter-container').innerHTML = htmlStr;
        
        // Make sure to call this function after updating the HTML.
        addToggleEventListeners();
    });
}



    function updateMap() {
        // Logic to update your map
        // Filter pins based on `filteredType` if it's not null
    }

    setInterval(fetchAndUpdateCounter, 5000);
    fetchAndUpdateCounter();
	
	function addToggleEventListeners() {
    const toggleStates = {};
    
    
    // Initialize the toggleStates object based on the data-toggled attributes
    document.querySelectorAll('.toggle-button').forEach(button => {
        const pinType = button.getAttribute('data-pin-type');
        toggleStates[pinType] = (button.getAttribute('data-toggled') === 'true');
    });

    document.querySelectorAll('.toggle-button').forEach(button => {
        button.addEventListener('click', () => {
            const pinType = button.getAttribute('data-pin-type');
            toggleStates[pinType] = !toggleStates[pinType];  // Toggle the state
            
            const untoggledIcon = button.querySelector('.untoggled-icon');
            const toggledIcon = button.querySelector('.toggled-icon');
            untoggledIcon.style.display = toggleStates[pinType] ? '' : 'none';
            toggledIcon.style.display = toggleStates[pinType] ? 'none' : '';
            
            document.querySelectorAll(`.pin-${pinType}`).forEach(markerElement => {
                markerElement.style.opacity = toggleStates[pinType] ? 1 : 0.05;
            });
        });
        
        // Set initial states for the icons and markers based on the toggleStates object
        const pinType = button.getAttribute('data-pin-type');
        const untoggledIcon = button.querySelector('.untoggled-icon');
        const toggledIcon = button.querySelector('.toggled-icon');
        untoggledIcon.style.display = toggleStates[pinType] ? '' : 'none';
        toggledIcon.style.display = toggleStates[pinType] ? 'none' : '';

        document.querySelectorAll(`.pin-${pinType}`).forEach(markerElement => {
            markerElement.style.opacity = toggleStates[pinType] ? 1 : 0.05;
        });
    });
}

</script>
<script>
function fetchAndDisplayCounters() {
    // Fetch the counter data from the server
    fetch('/get_counters')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
            }
            return response.json();
        })
        .then(data => {
            let counterContainer = document.getElementById("counter-container");
            let counterContainerMobile = document.getElementById("counter-container-mobile");
            }

            // Clear the existing counters
            counterContainer.innerHTML = "";
            counterContainerMobile.innerHTML = "";

            pinOrder.forEach(pin_type => {  // Loop through pin types in the specified order
                let counterValue = data[pin_type];

                let counterCircle = document.createElement("div");
                counterCircle.className = "counter-circle";
                counterCircle.style.backgroundColor = "#" + pin_type;
                counterCircle.innerText = counterValue;

                let counterCircleMobile = counterCircle.cloneNode(true);
                counterCircleMobile.innerText = counterValue;

                counterContainer.appendChild(counterCircle);
                counterContainerMobile.appendChild(counterCircleMobile);
            });
        })
        .catch(error => {
            console.error('There has been a problem with your fetch operation:', error);
        });
}

// You can call this function on page load, or as often as needed to refresh the counter
fetchAndDisplayCounters();
document.addEventListener('DOMContentLoaded', (event) => {
    addToggleEventListeners();  // Add the toggle event listener to the existing buttons
});

</script>
<!-- CSS PINS -->
<style>
.custom-popup .leaflet-popup-content {
    font-size: 40px; /* Adjust size as needed */
}

.countercontainer {
    border-radius: 30px;
    padding: 11px;
    color: white;
    position: absolute;
    top: 0;
    left: 50%;
    transform: translate(-50%, 0);
    z-index: 1000;  /* To ensure it's on top of other elements */
    text-align: center;  /* Center the content */
    display: flex;  /* Changed to flex */
    flex-wrap: nowrap;  /* Prevent wrapping onto new lines */
    justify-content: center;  /* Center items horizontally */
    min-width: 100px;  /* Optional: set a minimum width */
  display: flex;
    flex-wrap: nowrap;
    justify-content: center;
    overflow-x: auto;  /* Allow horizontal scrolling */
    white-space: nowrap;  /* Prevent wrapping onto new lines */
}

.togglebuttoncontainer {
    background-color: #3a3a3a;
    border-radius: 30px;
	opacity: 0;
    padding: 5px;
    color: black;
    position: absolute;
    top: 60px;  /* Adjusted top value */
    left: 50%;
    transform: translate(-50%, 0);
    z-index: 1020;  /* To ensure it's on top of other elements */
    text-align: center;  /* Center the content */
    display: inline-block;  /* Allow the container to resize based on content */
    min-width: 100px;  /* Optional: set a minimum width */
}
.togglebuttoncontainer img {
    margin: 0;
    padding: 0;
}

.togglebuttoncontainer img {
    vertical-align: middle;
}


.counter-wrapper {
    position: relative;
    display: inline-block;
}

    /* Remove button appearance */
.toggle-button {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
	opacity: 0;
}

/* Style for icons */
.icon {
    width: 24px; /* or whatever size you want */
    height: auto;
}
.heatmapsettings {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%; /* Optional: You can specify the height */
}

        #keyDiv {
            cursor: pointer;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center; /* Vertically center the image */
        }

        #keyDiv img {
            max-width: 40px;  /* Adjust size as needed */
            height: auto;
            border-radius: 30px;
            margin: 0;
        }
		
        #infoDiv {
            cursor: pointer;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center; /* Vertically center the image */
        }

        #infoDiv img {
            max-width: 40px;  /* Adjust size as needed */
            height: auto;
            border-radius: 30px;
            margin: 0;
        }
		
        #videoDiv {
            cursor: pointer;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center; /* Vertically center the image */
        }

        #videoDiv img {
            max-width: 40px;  /* Adjust size as needed */
            height: auto;
            border-radius: 30px;
            margin: 0;
        }
		
        #lightswitchDiv {
            cursor: pointer;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center; /* Vertically center the image */
        }

        #lightswitchDiv img {
            max-width: 40px;  /* Adjust size as needed */
            height: auto;
            border-radius: 30px;
            margin: 0;
        }

.countercontainer:hover .tooltip {
    display: block;
    opacity: 0;
    animation: fadeIn 0.5s forwards;
}

@keyframes fadeIn {
    to {
        opacity: 1;
    }
}

.counter-item {
    display: inline-block;
    margin-right: 20px;
    font-size: 15px;  /* Make the font bigger */
    font-weight: bold;  /* Make the font bolder */
}

.counter-item:last-child {
    margin-right: 0;  /* Remove margin-right for the last counter-item */
	    margin-left: 0;  /* Remove margin-right for the last counter-item */

}

.counter-circle {
    display: inline-block;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    margin-right: 5px;
    vertical-align: middle;
}

.countercontainer, .togglecontainer,
.countercontainer, .togglecontainer {
    position: absolute;
    top: 10px;
}
</style>
<style>
.bar {
    width: 25px;
    height: 3px;
    margin: 3px 0;
    background-color: #333;
}



#hamburger-dropdown .categorybutton {
	
}

.pin-label {
    background: none;
    border: none;
    font-size: 14px;
    font-weight: bold;
    color: red;
}

.delete-button {
    background-color: black;
    color: white;
    padding: 10px;
    cursor: pointer;
    border: none;
}



.options {
    display: none;
    position: absolute;
    z-index: 1;
    top: 100%;
    left: 0;
    width: 100%;
}

.dropdown:hover .options {
    display: block;
}




.hide-on-mobile.resistant-image,
.categorybutton {
  width: 100%;
  box-sizing: border-box;
}


/* Hide mobile version by default */
.current-mobile {
    display: none;
}

/* On larger screens, only show the desktop version */
@media screen and (min-width: 780px) {

    .current-mobile {
        display: none;
    }
	   #dropdown-options {
        display: none !important; /* Using !important to ensure this rule takes precedence over inline styles or other conflicting styles */
    }
}

/* On smaller screens (or equal to 780px), only show the mobile version */
@media screen and (max-width: 780px) {

    .current-mobile {
        display: block;
    }
}

.options {
    display: block; /* This shows the dropdown on mobile devices by default */
}

@media (max-width: 780px) {
    .countercontainer,
    .togglebuttoncontainer {
        border-radius: 25px;  /* Reduced border radius */
        padding: -10px;  /* Reduced padding */
        min-width: 50px;  /* Optional: reduced minimum width */
    }

    .togglebuttoncontainer img {
        width: 20px;  /* Reduced icon size */
        height: 20px;  /* Reduced icon size */
    }
}

/* Hide mappy-container by default */
#mappy-container {
    display: none;
}



/* Show mappy-container only on smaller screens */
@media (max-width: 780px) {
    #mappy-container {
        display: block;
        margin: 3px;
        width: calc(100% - 6px); /* Minus margin from both sides */
    }

    #mapMobile {
        height: 400px;
        width: 100%;
		border-radius: 30px;
position: relative;
    }
	
	 .hide-on-mobile {
        display: none !important;
    }
	
	

}

}
}


/* Hide mobile dropdown by default */
#categorybutton-mobile {
    display: none;
}

/* Show mobile dropdown and hide desktop menu on smaller screens */
@media (max-width: 780px) {
    #categorybutton-container {
        display: none;
    }
    #categorybutton-mobile {
        display: block;
    }
}


    h2 {
        margin-top: 0px;    /* Adjust as needed */
        margin-bottom: 0px; /* Adjust as needed */
    }
	
	
    .info-title {
        font-weight: bold;
        font-size: 25px;
        margin: 10px;
    }

 .info-subtitle {
        font-weight: bold;
        font-size: 24px;
        margin: 10px;
    }

    .info-text {
        font-size: 20px; /* Adjust the font size as needed */
    }


#current-selection {
    background-color: #ddd;
    padding: 10px;
    margin-bottom: 0px;
	margin-top: -5px;

}

.remove-star-button {
    background-color: #35b7ff;
    color: white;
    padding: 10px;
    cursor: pointer;
    border: none;
	margin-right: 5px;
	border-radius: 10px;
}

.pin-style {
    border: 3px solid transparent; /* Default transparent border */
    box-sizing: content-box; /* So that the border doesn't affect the pin's size */
    background: radial-gradient(circle, transparent 30%, transparent 100%);
    border-radius: 40%; 
    width: 24px; 
    height: 24px;
	    z-index: 300;
    position: relative;  /* Ensure that z-index applies */

}


.satellite-view .pin-FF7043 {
    background-image: radial-gradient(circle, #FF7043 50%, rgba(255, 177, 0, 0.7) 50%);
    border: 2px solid rgba(255, 255, 255, 0.9);
}

.satellite-view .pin-B71C1C {
    background-image: radial-gradient(circle, #B71C1C 50%, rgba(154, 3, 30, 0.7) 50%);
    border: 2px solid rgba(255, 255, 255, 0.9);
}

.satellite-view .pin-1565C0 {
    background-image: radial-gradient(circle, #1565C0 50%, rgba(19, 56, 115, 0.7) 50%);
    border: 2px solid rgba(255, 255, 255, 0.9);
}

.satellite-view .pin-4CAF50 {
    background-image: radial-gradient(circle, #4CAF50 50%, rgba(53, 134, 0, 0.7) 50%);
    border: 2px solid rgba(255, 255, 255, 0.9);
}

.satellite-view .pin-4E342E {
    background-image: radial-gradient(circle, #4E342E 50%, rgba(67, 19, 7, 0.7) 50%);
    border: 2px solid rgba(255, 255, 255, 0.9);
}

.satellite-view .pin-212121 {
    background-image: radial-gradient(circle, #212121 50%, rgba(7, 7, 7, 0.7) 50%);
    border: 2px solid rgba(255, 255, 255, 0.9);
}


.pin-FF7043 {
    color: #FF7043;
    background-image: radial-gradient(circle, #FF7043 30%, rgba(255, 177, 0, 0.2) 40%);
}

.pin-B71C1C {
    color: #B71C1C;
    background-image: radial-gradient(circle, #B71C1C 30%, rgba(154, 3, 30, 0.2) 40%);
}

.pin-1565C0 {
    color: #1565C0;
    background-image: radial-gradient(circle, #1565C0 30%, rgba(19, 56, 115, 0.2) 40%);
}

.pin-4CAF50 {
    color: #4CAF50;
    background-image: radial-gradient(circle, #4CAF50 30%, rgba(53, 134, 0, 0.2) 40%);
}

.pin-4E342E {
    color: #4E342E;
    background-image: radial-gradient(circle, #4E342E 30%, rgba(67, 19, 7, 0.2) 40%);
}

.pin-212121 {
    color: #212121;
    background-image: radial-gradient(circle, #212121 30%, rgba(7, 7, 7, 0.2) 40%);
}




.info-field {
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 10px;
    padding: 20px;
	border-radius: 30px;
    color: white;
    text-align: center; /* Center the text */
}


#current-selection {
    font-weight: bold;
    padding: 10px 0;
    margin: 2px 0;
    cursor: pointer;
    font-size: 20px;
    text-decoration: none;
    display: block;
    width: 100%;
    transition: background-color 0.2s ease-in-out;
    border-radius: 30px;
    box-sizing: border-box;
    text-align: center;
    background-color: white;
    color: black;
}

.dropdown-menu2 {

    font-weight: bold;
    margin: -1px 0;
	padding: 0px 10px;
    line-height: 0;  /* Adjust line-height */
    cursor: pointer;
    font-size: 24px;
    text-decoration: none;
    display: block;
    width: 100%;
    box-sizing: border-box; /* Ensure padding and border are included in the width */
    padding: 0px 10px; /* Adjust padding as per design requirement */
    transition: background-color 0.2s ease-in-out;
    border-radius: 30px;
    box-sizing: border-box;
    text-align: center;
}

    
}
.centered-text-container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    width: 100%; /* Ensure it takes up the full width of its parent. */
}

.centered-text-container h2 {
    font-size: 4vw; /* This will make the font size 4% of the viewport width. Adjust this as necessary. */
}

@media screen and (max-width: 780px) {
    .centered-text-container h2 {
        font-size: 5vw; /* Increase font size on smaller screens. Adjust as necessary. */
    }
}

.centered-text-container h2 {
    margin: 0; /* Removes default margins. Adjust if you need some spacing between them. */
    padding: 0; /* Removes any default padding. */
}



#sidebar h2 {
    margin: 0px 0;
}


.pin-FF7043 { color: #FF7043; }
.pin-B71C1C { color: #B71C1C; }
.pin-1565C0 { color: #1565C0; }
.pin-4CAF50 { color: #4CAF50; }
.pin-4E342E { color: #4E342E; }
.pin-212121 { color: #212121; }



  .xdxd {
      display: flex;
      justify-content: space-between;
    }
    .left-container, .right-container {
      display: flex;
      align-items: center;
    }
    .video-div, .info-div, .lightswitch-div, .key-div {
      margin: 0 3px;
    }
}

  
    /* Individual icon divs */
    .lightswitch-div, .key-div, .video-div, .info-div {
      flex-direction: row;
    }

    /* Make the containers hidden when screen width is less than 1271px */
    @media (max-width: 1271px) {
      .left-container, .right-container,  .togglebuttoncontainer  {
        display: none;
      }
    }
	
	  /* Make the containers hidden when screen width is less than 1271px */
    @media (max-width: 1050px) {
	.countercontainer {
	        display: none;

	    }
    }
	
#sidebar {
    display: flex;
    flex-direction: column;
    flex-basis: 30%;
    padding: 20px;
    background-color: ##405F5E;  /* Updated this line */
    margin-top: 15px;
	    margin-bottom: 15px ;
    margin-left: 15px ;
    margin-right: 15px;
  overflow-y: auto;  /* Makes the sidebar scrollable vertically */
    justify-content: flex-start;
    align-items: stretch;
    overflow: hidden;
}

#sidebar > * {
    min-height: 0;
    flex-grow: 0;
    flex-shrink: 0;
}
    border-radius: 10px;
	
}
.current {
    font-weight: bold;
    padding: 50px 0;
    cursor: pointer;
    font-size: 15px;
    text-decoration: none;
    display: block;
    width: 100%;
    transition: background-color 0.2s ease-in-out;
    border-radius: 30px;
    box-sizing: border-box;
    text-align: center;
       background-color: white;
    color: black;
}

.current:hover {
    background-color: #e0e0e0;
}


#feedbackText {
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 10px;
    font-weight: bold;
    border: none;
	background-color: #111111;
    cursor: pointer;
    font-size: 20px;
    text-decoration: none;
    display: inline-block;
    border-radius: 10px;
    transition: background-color 0.2s ease-in-out;
    resize: none; /* Disables resizing of the textarea */
}

#postFeedback {
    background-color: #4CAF50;
    border: none;
    color: white;
    padding: 10px 20px;
    border-radius: 10px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s ease-in-out;
}

#postFeedback:hover {
    background-color: #388E3C;
}

#cancelFeedback {
    background-color: #B71C1C;
    border: none;
    color: white;
    padding: 10px 20px;
    border-radius: 10px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s ease-in-out;
}

#cancelFeedback:hover {
    background-color: #9E0B0B;
}



/* Make sure the HTML and body take up the full viewport height */
html, body {
    height: 100%;
    margin: 0;
    padding: 0;
}
body {
    font-family: 'Roboto', sans-serif;
}





h3 {
    text-align: center; /* Center text horizontally */

    /* If you want to center the h2 vertically within its container, you can use these properties, but they might not be necessary for all use cases: */
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}
h2 {
    text-align: center; /* Center text horizontally */

    /* If you want to center the h2 vertically within its container, you can use these properties, but they might not be necessary for all use cases: */
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}
.leaflet-container .leaflet-tile {
    border: none !important;
    outline: none !important;
    box-shadow: none !important;
}

@media screen and (min-width: 780px) {
    #dropdown-button {
        display: none;
		margin-top:10px;

    }
	
	
}

@media screen and (max-width: 780px) {
    .categorybutton {
	 font-size: 2vw; /* adjust as needed */
        max-height: calc(2em + 14px); /* 2 times the font size + 2 times the padding */
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
		 display: flex;
        justify-content: center;
        align-items: center;
        height: auto;  // This ensures the container grows with its content
        padding: 7px;

    }
}

@media screen and (min-width: 780px) {
    #dropdown-options {
        display: none !important; /* Important can ensure that this rule takes precedence over inline styles */
    }
}

@media screen and (max-width: 780px) {


.dropdown-container {
    width: 100%; /* Ensure the container takes full width of its parent */
    padding: 0;  /* Remove padding so children can stretch fully */
    box-sizing: border-box; /* This will include any padding and borders in the element's total width */
	   position: relative;
}
    ...
.clearfix::after {
    content: "";
    display: table;
    clear: both;
}

/* Dropdown button */
   #dropdown-button {
           font-weight: bold;
    border: 5px solid #0D1F22;
    padding: 7px 0;
    margin: 2px 0;
    cursor: pointer;
    font-size: 24px;
    text-decoration: none;
    display: block;
    width: 100%;
    transition: background-color 0.2s ease-in-out;
    border-radius: 30px;
    box-sizing: border-box;
    text-align: center;
    color: white;
	    z-index: 2;  /* Ensure it's above the dropdown-options in stacking order */

}

	
/* Dropdown icon (you can use an actual icon; this is just for demonstration) */
#dropdown-button:after {
    content: "▼"; /* A downward arrow; you can replace this with an SVG or another icon */
    width: 100%; /* Stretching across the entire boundaries */
        margin-left: 0; /* Removing left margin */
        margin-right: 0; /* Removing right margin */
    }


/* Options that appear on dropdown click */
#dropdown-options {
    border-top: none; /* Remove top border to blend with dropdown button */
    border-radius: 0 0 10px 10px; /* Only round bottom corners */
	max-width: 100%;
    top: 100%;  /* Positioning it right below the dropdown-button */
		  width: 100%;
        left: 0;
        right: 0;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
	    z-index: 1;  /* Ensure it's above the dropdown-options in stacking order */

}

  h3 + h3 {
        margin-top: -10px; /* Adjust this value to control the gap. Negative values bring the lines closer together. */
    }

    h2 + h2 {
        margin-top: -10px; /* Adjust this value to control the gap. Negative values bring the lines closer together. */
    }

    .main-container {
        display: flex;
        width: 100%;  /* Ensure this container takes the full width */
        height: 100%;
        flex-direction: column;
        align-items: center; 
        justify-content: flex-start;
        padding: 0;  /* Ensure no padding */
        margin: 0;  /* Ensure no margin */
    }
 #sidebar {
        width: 95%; 
        max-width: 95%;  /* Ensure it doesn't go beyond this width */
        padding: 10px;
        box-sizing: border-box; 
        height: auto; 
        margin: 0 auto;  /* Centering shorthand */
    }

    #mapContainer {
        width: 90%;  /* 5% margin on each side */
        height: 300px;  /* Fixed height for mobile, adjust if necessary */
        margin: 5% auto;  /* Center the map container horizontally */
    }

    #map {
        display: none;

    }
}



@media screen and (max-width: 780px) {
   
   div[style="display: flex; height: 100vh"] {
        flex-direction: column;
        align-items: center;     
        justify-content: flex-start;
    }
    
    /* Logo at the top */
    img[src="static/logo_long.png"] {
        display: block;
        max-width: 90%;
		        width: 90%;

		        height: auto;
                margin-left: auto;
        margin-right: auto;
		
    }
    
   
    /* Map below headings */



    
    /* Container adjustment */
    div[style="display: flex; height: 100vh"] {
        flex-direction: column;
    }




}





<!-- CATEGORY EDITING AREA START -->
.cursor-pin-FF7043 { 
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="%23FF7043" /></svg>'), auto; 
}
.cursor-pin-B71C1C { 
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="%23B71C1C" /></svg>'), auto; 
}
.cursor-pin-1565C0 { 
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="%231565C0" /></svg>'), auto; 
}
.cursor-pin-4CAF50 { 
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="%234CAF50" /></svg>'), auto; 
}
.cursor-pin-4E342E { 
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="%234E342E" /></svg>'), auto; 
}
.cursor-pin-212121 { 
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="%23212121" /></svg>'), auto; 
}
<!-- CATEGORY EDITING AREA END -->
</style>
<script>
function applyColor() {
    let selectedOption = $('#pin-dropdown option:selected');
    let color = selectedOption.data('color');
    // Handle your color or functionality here
    console.log(color);  // For testing purposes
}
</script>
<!-- HAMBURGER MENU CLOSING LOGIC -->
<script>
</script>
<!-- PIN CARRYING UPON CLICK -->
<script>
document.querySelectorAll(".categorybutton").forEach(menu => {
    menu.addEventListener("click", function() {
        selectedColor = this.getAttribute("data-color");
        document.getElementById("selected-pin-type").innerText = pins[selectedColor];
        document.getElementById("selected-pin-type").style.color = "#" + selectedColor;

        // Update cursor style
        map.getContainer().classList.remove(...Array.from(map.getContainer().classList).filter(c => c.startsWith('cursor-pin-')));
        map.getContainer().classList.add(`cursor-pin-${selectedColor}`);
    });
});

map.on('click', function(e) {
    // Rest of your existing logic

    // Remove custom cursor after pin is placed
    map.getContainer().classList.remove(...Array.from(map.getContainer().classList).filter(c => c.startsWith('cursor-pin-')));
});
</script>
<!-- PIN RETRIEVAL -->
<script>
document.addEventListener("DOMContentLoaded", function() {
    fetch('/get_pins')  // Assuming '/get_pins' is the endpoint that returns all pins
    .then(response => response.json())
    .then(data => {
        if(data && data.pins) {
            loadPins(data.pins);
        }
    });
});

function loadPins(pins) {
            pins.forEach(pin => {
                const starHtml = pin.highlight_id ? `<div class="star-icon-wrapper"><img src="/static/star_icon.png" class="leaflet-marker-icon star-icon" alt="" tabindex="0" data-pin-type="${pin.pin_type}" style="width: ${starIconSize}px; height: ${starIconSize}px;"></div>` : '';

                const markerHtml = `
                    <div style="position: relative; text-align: center; width: ${pinSize}px;">
                        <div class="molen-id hidden" style="position: absolute; width: 100%; top: -15px;">M${pin.molen_id}</div>
                        <div class="pin-style pin-${pin.pin_type}" style="width: ${pinSize}px; height: ${pinSize}px;">${starHtml}</div>
                    </div>
                `;



        const markerIcon = L.divIcon({
            className: '',
            iconSize: [pinSize, pinSize],
            html: markerHtml
        });

        // Your existing code
const deleteButtonHtml = `<button class="delete-button" style="margin-top: 5px; margin-right: 5px; background-color: #35b7ff; border-radius: 10px" data-pin-id="${pin.id}" data-molen-id="${pin.molen_id}">📍 Löschen</button>`;
const starButtonHtml = `<button class="star-button" data-molen-id="${pin.molen_id}">⭐ Markieren</button>`;
const removeStarButtonHtml = pin.highlight_id ? `<button class="remove-star-button" onclick="removeStar('${pin.molen_id}')">⭐ Entfernen</button>` : '';
const popupContent = `<div>${starButtonHtml}${deleteButtonHtml}${removeStarButtonHtml}</div><div>${pin.description}</div>`;


// Wrapping the existing popupContent
const wrappedPopupContent = `<div>${popupContent}</div><div>${pin.description}</div>`;

        const markerMap = L.marker([pin.lat, pin.lon], { icon: markerIcon }).bindPopup(popupContent);
        const markerMapMobile = L.marker([pin.lat, pin.lon], { icon: markerIcon }).bindPopup(popupContent);

        markerMap.addTo(map);
        markerMapMobile.addTo(mapMobile);

        // Removed old star icon creation logic

        markerMap.on('popupopen', function(event) {
            handleStarButtonClick(event);
            handleDeleteButtonClick(event);
        });
        
        markerMapMobile.on('popupopen', function(event) {
            handleStarButtonClick(event);
            handleDeleteButtonClick(event);
        });
    });
}

function handleStarButtonClick(event) {
    const starButton = event.popup._contentNode.querySelector('.star-button');
    if (starButton) {
        starButton.addEventListener('click', function() {
            const molenId = this.getAttribute('data-molen-id');
            highlightPin(molenId);
        });
    }
}

function highlightPin(molenId) {
    fetch(`/highlight_pin/${molenId}`, { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                refreshMap();
            }
        });
}

function loadHeatmap(pins) {
    heatmapData = pins.map(pin => [parseFloat(pin.lat), parseFloat(pin.lon), 0.5])
                      .filter(coord => !isNaN(coord[0]) && !isNaN(coord[1]));
    if (heatmapLayer) {
        console.log("Heatmap data:", heatmapData);  // Log the data
        heatmapLayer.setLatLngs(heatmapData);
        console.log("Heatmap data updated");
    }
}


// Your existing refreshMap function
function refreshMap() {
    // Clear existing layers
    map.eachLayer(layer => map.removeLayer(layer));
    mapMobile.eachLayer(layer => mapMobile.removeLayer(layer));

    // Re-add heatmap layers to avoid deletion
	  heatmapLayer.addTo(map);
		heatmapLayerMobile.addTo(mapMobile);
	  
		fetch('/get_pins')
		.then(response => response.json())
		.then(data => {
			if(data && data.pins) {
				loadPins(data.pins);
				loadHeatmap(data.pins);  // Refresh heatmap
			}
		});
	}
	
function updateHeatmapSettings() {
  const minOpacity = parseFloat(document.getElementById('minOpacity').value);
  const maxZoom = parseInt(document.getElementById('maxZoom').value);
  const max = parseFloat(document.getElementById('max').value);
  const radius = parseInt(document.getElementById('radius').value);
  const blur = parseInt(document.getElementById('blur').value);
  const gradient = JSON.parse(document.getElementById('gradient').value);

  // Update settings for heatmapLayer
  if (heatmapLayer) {
    heatmapLayer.setOptions({
      minOpacity: minOpacity,
      maxZoom: maxZoom,
      max: max,
      radius: radius,
      blur: blur,
      gradient: gradient
    });
    console.log("heatmapLayer settings updated");
  }

  // Update settings for heatmapLayerMobile (if it exists)
  if (heatmapLayerMobile) {
    heatmapLayerMobile.setOptions({
      minOpacity: minOpacity,
      maxZoom: maxZoom,
      max: max,
      radius: radius,
      blur: blur,
      gradient: gradient
    });
    console.log("heatmapLayerMobile settings updated");
  }
}


function handleDeleteButtonClick(event) {
    const deleteButton = event.popup._contentNode.querySelector('.delete-button');
    if (deleteButton) {
        deleteButton.addEventListener('click', function() {
            const molenId = this.getAttribute('data-molen-id');
            deletePinByMolenId(molenId);
        });
    }
}

function deletePinByMolenId(molenId) {
    fetch(`/delete_pin_by_molen_id/${molenId}`, { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                refreshMap();
            }
        });
}


function removeStar(molenId) {
    fetch(`/remove_star/${molenId}`, { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                refreshMap();
            }
        });
}




function applyColor() {
    let selectedOption = document.querySelector('#pin-dropdown option:checked');
    let color = selectedOption.getAttribute('data-color');
    console.log(color);  // For testing purposes
}

document.querySelectorAll(".pin-menu").forEach(menu => {
    menu.addEventListener("click", function() {
        let selectedColor = this.getAttribute("data-color");
        document.getElementById("selected-pin-type").innerText = pins[selectedColor];
        document.getElementById("selected-pin-type").style.color = "#" + selectedColor;

        // Update cursor style for both maps
        map.getContainer().classList.remove(...Array.from(map.getContainer().classList).filter(c => c.startsWith('cursor-pin-')));
        mapMobile.getContainer().classList.remove(...Array.from(mapMobile.getContainer().classList).filter(c => c.startsWith('cursor-pin-')));
        
        map.getContainer().classList.add(`cursor-pin-${selectedColor}`);
        mapMobile.getContainer().classList.add(`cursor-pin-${selectedColor}`);
    });
});

// Handle pin placement for both maps
function handleMapClick(mapInstance) {
    mapInstance.on('click', function(e) {
        const markerIcon = L.divIcon({
            className: `pin-style pin-${selectedColor}`,  // Assuming 'selectedColor' is the selected pin color
            iconSize: [24, 24]
        });
        
        const marker = L.marker([e.latlng.lat, e.latlng.lon], { icon: markerIcon }).bindPopup('Description Here'); // Replace 'Description Here' as needed
        marker.addTo(mapInstance);

        // Optionally, add logic to save the pin to your server
    });
    
    // Remove custom cursor after pin is placed
    mapInstance.getContainer().classList.remove(...Array.from(mapInstance.getContainer().classList).filter(c => c.startsWith('cursor-pin-')));
}

handleMapClick(map);
handleMapClick(mapMobile);
</script>

<script>
        // JavaScript function to toggle the login popup
        function togglePopup() {
            const popup = document.getElementById('loginPopup');
            popup.style.display = popup.style.display === 'block' ? 'none' : 'block';
        }

        // Your existing addAndRemoveClass function
        function addAndRemoveClass() {
    // Get the button element
    const buttonMenu = document.getElementById('buttonMenu');

    // Add the 'selected' class
    buttonMenu.classList.add('selected');

    setTimeout(function() {
        buttonMenu.classList.remove('selected');
    }, 15000);
}
    </script>
<script>
function deletePin(pinId) {
    fetch(`/delete_pin/${pinId}`, { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                refreshMap();
            }
        });
}



function reloadHeatmapAfterDeletion() {
    fetch('/get_pins')
    .then(response => response.json())
    .then(data => {
        if (data && data.pins) {
            loadHeatmap(data.pins);  // Refresh heatmap
        }
    });
}


function refreshMap() {
    map.eachLayer(layer => {
        if (layer instanceof L.Marker) {
            map.removeLayer(layer);
        }
    });
    mapMobile.eachLayer(layer => {
        if (layer instanceof L.Marker) {
            mapMobile.removeLayer(layer);
        }
    });
    fetch('/get_pins')
        .then(response => response.json())
        .then(data => {
            if (data && data.pins) {
                loadPins(data.pins);
            }
        });
}

</script>
</div>



<!-- DARK LIGHT MODE SWITCH -->
<script>
  console.log("Light mode script loaded.");
  let isLightMode = false;  // Initialize with dark mode

// Function to switch between light and dark mode
function toggleLightMode() {
  console.log("Toggling light mode.");
  const elements1b1b1b = document.querySelectorAll('.color-1b1b1b');
  const elements111111 = document.querySelectorAll('.color-111111');
  const elements3a3a3a = document.querySelectorAll('.color-3a3a3a');
  const elements000000 = document.querySelectorAll('.color-000000');
  const textElements = document.querySelectorAll('.text-white');
  const logoElement = document.querySelector('.logo-img');
  const videoIcon = document.querySelector('#videoDiv img');
  const infoIcon = document.querySelector('#infoDiv img');
  const sunIcon = document.querySelector('#lightswitchDiv img');
  const keyIcon = document.querySelector('#keyDiv img');
  const counterContainer = document.getElementById('counter-container');

    // Query selectors for Leaflet controls
  const leafletBar = document.querySelectorAll('.leaflet-bar');
  const zoomInButtons = document.querySelectorAll('.leaflet-control-zoom-in');
  const zoomOutButtons = document.querySelectorAll('.leaflet-control-zoom-out');
  const leafletLayersList = document.querySelectorAll('.leaflet-control-layers-expanded .leaflet-control-layers-list');
  const leafletLayersExpanded = document.querySelectorAll('.leaflet-control-layers-expanded');
  const leafletDisabled = document.querySelectorAll('.leaflet-disabled');


  if (isLightMode) {
    document.body.style.backgroundColor = '#1b1b1b';
    elements1b1b1b.forEach(el => el.style.backgroundColor = '#1b1b1b');
    elements111111.forEach(el => el.style.backgroundColor = '#111111');
    elements3a3a3a.forEach(el => el.style.backgroundColor = '#3a3a3a');
    elements000000.forEach(el => el.style.backgroundColor = '#000000');
    textElements.forEach(el => el.style.color = 'white');
    logoElement.src = 'static/logo_long.png';
	videoIcon.src = 'static/videoicon.png';
    infoIcon.src = 'static/infoicon.png';
    sunIcon.src = 'static/sunicon.png';
    keyIcon.src = 'static/keyicon.png';
    counterContainer.style.backgroundColor = '#3a3a3a';
    counterContainer.style.color = 'white';  // Resetting text color to white in dark mode
	
	// Updating Leaflet controls for dark mode
    leafletBar.forEach(el => el.style.backgroundColor = '#3a3a3a !important');
    zoomInButtons.forEach(el => {
      el.style.backgroundColor = '#3a3a3a !important';
      el.style.color = 'white !important';
    });
    zoomOutButtons.forEach(el => {
      el.style.backgroundColor = '#3a3a3a !important';
      el.style.color = 'white !important';
    });
    leafletLayersList.forEach(el => el.style.color = 'white');
    leafletLayersExpanded.forEach(el => el.style.backgroundColor = '#3a3a3a !important');
    leafletDisabled.forEach(el => {
      el.style.backgroundColor = '#111111 !important';
      el.style.color = 'white !important';
    });
  } else {
    document.body.style.backgroundColor = '#F4F4ED';
    elements1b1b1b.forEach(el => el.style.backgroundColor = '#F4F4ED');
    elements111111.forEach(el => el.style.backgroundColor = '#D4D7DA');
    elements3a3a3a.forEach(el => el.style.backgroundColor = '#000000');
    elements000000.forEach(el => el.style.backgroundColor = '#ffffff');
    textElements.forEach(el => el.style.color = 'black');
    logoElement.src = 'static/logo_long2.png';
	videoIcon.src = 'static/videoicon2.png';
    infoIcon.src = 'static/infoicon2.png';
    sunIcon.src = 'static/sunicon2.png';
    keyIcon.src = 'static/keyicon2.png';
    
    // Updating counter-container background color and text color for light mode
    counterContainer.style.backgroundColor = '#F4F4ED';
    counterContainer.style.color = 'black';  // Changing text color to black in light mode
    leafletBar.forEach(el => el.style.backgroundColor = '#f4f4ed !important');
    zoomInButtons.forEach(el => {
      el.style.backgroundColor = '#f4f4ed !important';
      el.style.color = 'black !important';
    });
    zoomOutButtons.forEach(el => {
      el.style.backgroundColor = '#f4f4ed !important';
      el.style.color = 'black !important';
    });
    leafletLayersList.forEach(el => el.style.color = 'black');
    leafletLayersExpanded.forEach(el => el.style.backgroundColor = '#f4f4ed !important');
    leafletDisabled.forEach(el => {
      el.style.backgroundColor = '#d4d7da !important';
      el.style.color = 'black !important';
    });
  }
  
  isLightMode = !isLightMode;  // Toggle the mode
}


  // Add event listener to the light switch div
  document.getElementById('lightswitchDiv').addEventListener('click', toggleLightMode);
</script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        // Get the form and the add category button
        const form = document.getElementById("new-category-form");
        const addButton = document.getElementById("add-category-button");

        // Attach an event listener to the add category button
        addButton.addEventListener("click", function() {
            // Collect the form data
            const formData = new FormData(form);
            const name = formData.get("category-name");
            const color = formData.get("category-color");
            const popupText = formData.get("category-popup");

            // Make an AJAX request to add the new category
            fetch("/add_category", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    name: name,
                    color: color,
                    popup_text: popupText
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.message) {
                    alert("Category added successfully!");
                    // Reload or update the UI as needed
                } else {
                    alert("Error: " + data.error);
                }
            })
            .catch(error => {
                alert("An error occurred: " + error);
            });
        });
    });
	
	document.addEventListener("DOMContentLoaded", function() {
    // Identify the star icon by its src attribute
    const starIcon = document.querySelector('img[src="/static/star_icon.png"]');
    
    starIcon.addEventListener("click", function(event) {
        const rect = starIcon.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Find the underlying element (pin)
        const elemBelow = document.elementFromPoint(x, y);
        
        // Forward the click to the pin
        if (elemBelow && elemBelow.classList.contains("pin-style")) {
            elemBelow.click();
        }
    });
});
</script>

<!-- Button to enable heatmap -->
<div style="position: fixed; bottom: 20px; right: 20px; z-index: 0; opacity: 0">
    <button id="enableHeatmap" onclick="toggleHeatmap()">Enable Heatmap</button>
</div>




<script>
    
    let heatmapData = [];

    // Initialize heatmap after map is fully loaded
    map.whenReady(function() {
        heatmapLayer = L.heatLayer(heatmapData, { radius: 25 });
        console.log("Heatmap layer initialized");
    });

    function loadHeatmap(pins) {
        heatmapData = pins.map(pin => [parseFloat(pin.lat), parseFloat(pin.lon), 0.5])
                          .filter(coord => !isNaN(coord[0]) && !isNaN(coord[1]));
        if (heatmapLayer) {
            console.log("Heatmap data:", heatmapData);
            heatmapLayer.setLatLngs(heatmapData);
            console.log("Heatmap data updated");
        }
    }

    // Toggle heatmap
    let heatmapEnabled = false;
    function toggleHeatmap() {
    if (map.hasLayer(heatmapLayer)) {
        map.removeLayer(heatmapLayer);
    } else {
        heatmapLayer.addTo(map);
    }
}
</script>





<script>
    // Check if heatmapLayer and heatmapData are already defined
    let heatmapLayer = typeof heatmapLayer !== 'undefined' ? heatmapLayer : null;
    let heatmapData = typeof heatmapData !== 'undefined' ? heatmapData : [];

    // Initialize heatmap and toggle function after map is fully loaded
    map.whenReady(function() {
        if (!heatmapLayer) {
            heatmapLayer = L.heatLayer(heatmapData, { radius: 25 });
            console.log("Heatmap layer initialized");
        }

        // Toggle heatmap
        document.getElementById("enableHeatmap").addEventListener("click", function() {
            let heatmapEnabled = heatmapLayer._map ? true : false;
            if (heatmapEnabled) {
                heatmapLayer.remove();
                this.textContent = "Enable Heatmap";
                console.log("Heatmap disabled");
            } else {
                heatmapLayer.addTo(map);
                this.textContent = "Disable Heatmap";
                console.log("Heatmap enabled");
            }
        });
    });

    function loadHeatmap(pins) {
        heatmapData = pins.map(pin => [parseFloat(pin.lat), parseFloat(pin.lon), 0.5])
                          .filter(coord => !isNaN(coord[0]) && !isNaN(coord[1]));
        if (heatmapLayer) {
            console.log("Heatmap data:", heatmapData);
            heatmapLayer.setLatLngs(heatmapData);
            console.log("Heatmap data updated");
        }
    }
</script>


<script>
// Check if hexLayer and hexData are already defined
let hexLayer = typeof hexLayer !== 'undefined' ? hexLayer : null;
let hexData = typeof hexData !== 'undefined' ? hexData : [];

// Initialize hexagon and toggle function after map is fully loaded
map.whenReady(function() {
    if (!hexLayer) {
        hexLayer = L.hexbinLayer({
            radius: 25,
            opacity: 0.5,
            colorScaleExtent: [1, undefined]
        }).addTo(map);
        console.log("Hexagon layer initialized");
    }

    // Toggle hexagon layer
    document.getElementById("enableHexagon").addEventListener("click", function() {
        let hexagonEnabled = hexLayer._map ? true : false;
        if (hexagonEnabled) {
            hexLayer.remove();
            this.textContent = "Enable Hexagon";
            console.log("Hexagon layer disabled");
        } else {
            hexLayer.addTo(map);
            this.textContent = "Disable Hexagon";
            console.log("Hexagon layer enabled");
        }
    });
});

// Function to load hexagon data
function loadHexagon(pins) {
    hexData = pins.map(pin => [parseFloat(pin.lat), parseFloat(pin.lon)])
                 .filter(coord => !isNaN(coord[0]) && !isNaN(coord[1]));
    if (hexLayer) {
        console.log("Hexagon data:", hexData);
        hexLayer.data(hexData);
        console.log("Hexagon data updated");
    }
}


</script>



</body>
<audio id="buttonClickAudio"><source src="static/buttonclick.mp3" type="audio/mp3"/></audio>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Get the audio element
    const audio = document.getElementById('buttonClickAudio');
    
    // Add click event listener to all elements with class 'button-menu'
    const buttonMenus = document.querySelectorAll('.button-menu');
    buttonMenus.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });

    // Add click event listener to all elements with class 'categorybutton'
    const categorybuttons = document.querySelectorAll('.categorybutton');
    categorybuttons.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
	    // Add click event listener to all elements with class 'button-menu'
    const keyDivs = document.querySelectorAll('.key-div');
    keyDivs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
	    // Add click event listener to all elements with class 'button-menu'
    const videoDivs = document.querySelectorAll('.video-div');
    videoDivs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
		    // Add click event listener to all elements with class 'button-menu'
    const lightswitchDivs = document.querySelectorAll('.lightswitch-div');
    lightswitchDivs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
		    // Add click event listener to all elements with class 'button-menu'
    const infoDivs = document.querySelectorAll('.info-div');
    infoDivs.forEach((button) => {
        button.addEventListener('click', function() {
            audio.play();
        });
    });
	
});
</script>
<script>
document.getElementById('aboutBtnEditor').addEventListener('click', function() {
    document.getElementById('infoModalEditor').style.display = 'flex';
});

// Close the modal when clicking outside the info field
document.getElementById('infoModalEditor').addEventListener('click', function(event) {
    if (event.target === this) {
        this.style.display = 'none';
    }
});
</script>
<script>
document.getElementById('aboutBtnEditorAdminMenu').addEventListener('click', function() {
    document.getElementById('infoModalEditorAdminMenu').style.display = 'flex';
});

// Close the modal when clicking outside the info field
document.getElementById('infoModalEditorAdminMenu').addEventListener('click', function(event) {
    if (event.target === this) {
        this.style.display = 'none';
    }
});
</script>
<audio id="buttonClickAudio2"><source src="static/buttonclickSuccess.mp3" type="audio/mp3"/></audio>
<audio id="buttonClickAudio3"><source src="static/buttonclickClose.mp3" type="audio/mp3"/></audio>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Get the audio elements
    const audioSuccess = document.getElementById('buttonClickAudio2');
    const audioClose = document.getElementById('buttonClickAudio3');
    
    // Add event listener to the body element for delegation
    document.body.addEventListener('click', function(event) {
        if (event.target.id === 'postFeedback') {
            audioSuccess.play();
        } else if (event.target.id === 'cancelFeedback') {
            audioClose.play();
        }
    });
});

// Add event listeners to HTML input fields to update and save settings immediately
document.getElementById('minOpacity').addEventListener('change', updateHeatmapSettings);
document.getElementById('maxZoom').addEventListener('change', updateHeatmapSettings);
document.getElementById('max').addEventListener('change', updateHeatmapSettings);
document.getElementById('radius').addEventListener('change', updateHeatmapSettings);
document.getElementById('blur').addEventListener('change', updateHeatmapSettings);
document.getElementById('gradient').addEventListener('change', updateHeatmapSettings);

// Load saved settings on page load
window.addEventListener('load', function() {
    loadSettings();
});

// Update Settings button already calls updateHeatmapSettings() as per your HTML
</script>
